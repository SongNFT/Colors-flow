import reactDom from"react-dom";import react from"react";var Recoil_nullthrows=function(x,message){if(null!=x)return x;throw new Error(null!=message?message:"Got unexpected null or undefined")};var Recoil_recoverableViolation=function(message,projectName,{error:error}={}){return null};var Recoil_CopyOnWrite={setByAddingToSet:function(set,v){const next=new Set(set);return next.add(v),next},setByDeletingFromSet:function(set,v){const next=new Set(set);return next.delete(v),next},mapBySettingInMap:function(map,k,v){const next=new Map(map);return next.set(k,v),next},mapByUpdatingInMap:function(map,k,updater){const next=new Map(map);return next.set(k,updater(next.get(k))),next},mapByDeletingFromMap:function(map,k){const next=new Map(map);return next.delete(k),next},mapByDeletingMultipleFromMap:function(map,ks){const next=new Map(map);return ks.forEach(k=>next.delete(k)),next}};var Recoil_filterIterable=function*(iterable,predicate){let index=0;for(const value of iterable)predicate(value,index++)&&(yield value)};const gks=(new Map).set("recoil_hamt_2020",!0);function Recoil_gkx(gk){var _gks$get;return null!==(_gks$get=gks.get(gk))&&void 0!==_gks$get&&_gks$get}Recoil_gkx.setPass=gk=>{gks.set(gk,!0)},Recoil_gkx.setFail=gk=>{gks.set(gk,!1)};var Recoil_gkx_1=Recoil_gkx;var Recoil_mapIterable=function(iterable,callback){return function*(){let index=0;for(const value of iterable)yield callback(value,index++)}()};function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}class AbstractRecoilValue{constructor(newKey){_defineProperty(this,"key",void 0),this.key=newKey}}class RecoilState extends AbstractRecoilValue{}class RecoilValueReadOnly extends AbstractRecoilValue{}var Recoil_RecoilValue={AbstractRecoilValue:AbstractRecoilValue,RecoilState:RecoilState,RecoilValueReadOnly:RecoilValueReadOnly,isRecoilValue:function(x){return x instanceof RecoilState||x instanceof RecoilValueReadOnly}},Recoil_RecoilValue_1=Recoil_RecoilValue.AbstractRecoilValue,Recoil_RecoilValue_2=Recoil_RecoilValue.RecoilState,Recoil_RecoilValue_3=Recoil_RecoilValue.RecoilValueReadOnly,Recoil_RecoilValue_4=Recoil_RecoilValue.isRecoilValue,Recoil_RecoilValue$1=Object.freeze({__proto__:null,AbstractRecoilValue:Recoil_RecoilValue_1,RecoilState:Recoil_RecoilValue_2,RecoilValueReadOnly:Recoil_RecoilValue_3,isRecoilValue:Recoil_RecoilValue_4});class DefaultValue{}const DEFAULT_VALUE=new DefaultValue;class RecoilValueNotReady extends Error{constructor(key){super(`Tried to set the value of Recoil selector ${key} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const nodes=new Map,recoilValues=new Map;class NodeMissingError extends Error{}const configDeletionHandlers=new Map;function getConfigDeletionHandler(key){return configDeletionHandlers.get(key)}var Recoil_Node={nodes:nodes,recoilValues:recoilValues,registerNode:function(node){if(nodes.has(node.key)){const message=`Duplicate atom key "${node.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(message)}nodes.set(node.key,node);const recoilValue=null==node.set?new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key):new Recoil_RecoilValue$1.RecoilState(node.key);return recoilValues.set(node.key,recoilValue),recoilValue},getNode:function(key){const node=nodes.get(key);if(null==node)throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);return node},getNodeMaybe:function(key){return nodes.get(key)},deleteNodeConfigIfPossible:function(key){var _node$shouldDeleteCon;if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const node=nodes.get(key);var _getConfigDeletionHan;(null==node||null===(_node$shouldDeleteCon=node.shouldDeleteConfigOnRelease)||void 0===_node$shouldDeleteCon?void 0:_node$shouldDeleteCon.call(node))&&(nodes.delete(key),null===(_getConfigDeletionHan=getConfigDeletionHandler(key))||void 0===_getConfigDeletionHan||_getConfigDeletionHan(),configDeletionHandlers.delete(key))},setConfigDeletionHandler:function(key,fn){Recoil_gkx_1("recoil_memory_managament_2020")&&(void 0===fn?configDeletionHandlers.delete(key):configDeletionHandlers.set(key,fn))},getConfigDeletionHandler:getConfigDeletionHandler,recoilValuesForKeys:function(keys){return Recoil_mapIterable(keys,key=>Recoil_nullthrows(recoilValues.get(key)))},NodeMissingError:NodeMissingError,DefaultValue:DefaultValue,DEFAULT_VALUE:DEFAULT_VALUE,RecoilValueNotReady:RecoilValueNotReady};class RetentionZone{}var Recoil_RetentionZone={RetentionZone:RetentionZone,retentionZone:function(){return new RetentionZone}};const{setByAddingToSet:setByAddingToSet$1}=Recoil_CopyOnWrite,{getNode:getNode$1,getNodeMaybe:getNodeMaybe$1,recoilValuesForKeys:recoilValuesForKeys$1}=Recoil_Node,{RetentionZone:RetentionZone$1}=Recoil_RetentionZone,emptySet=Object.freeze(new Set);class ReadOnlyRecoilValueError extends Error{}function initializeNodeIfNewToStore(store,treeState,key,trigger){const storeState=store.getState();if(storeState.nodeCleanupFunctions.has(key))return;const config=getNode$1(key),retentionCleanup=function(store,nodeKey,retainedBy){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:nodesRetainedByZone}=store.getState().retention;function addToZone(zone){let set=nodesRetainedByZone.get(zone);set||nodesRetainedByZone.set(zone,set=new Set),set.add(nodeKey)}if(retainedBy instanceof RetentionZone$1)addToZone(retainedBy);else if(Array.isArray(retainedBy))for(const zone of retainedBy)addToZone(zone);return()=>{if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const nodesRetainedByZone=store.getState().retention.nodesRetainedByZone;function deleteFromZone(zone){const set=nodesRetainedByZone.get(zone);set&&set.delete(nodeKey),set&&0===set.size&&nodesRetainedByZone.delete(zone)}if(retainedBy instanceof RetentionZone$1)deleteFromZone(retainedBy);else if(Array.isArray(retainedBy))for(const zone of retainedBy)deleteFromZone(zone)}}(store,key,config.retainedBy),nodeCleanup=config.init(store,treeState,trigger);storeState.nodeCleanupFunctions.set(key,()=>{nodeCleanup(),retentionCleanup()})}function peekNodeLoadable(store,state,key){return getNode$1(key).peek(store,state)}function getDownstreamNodes(store,state,keys){const visitedNodes=new Set,visitingNodes=Array.from(keys),graph=store.getGraph(state.version);for(let key=visitingNodes.pop();key;key=visitingNodes.pop()){var _graph$nodeToNodeSubs;visitedNodes.add(key);const subscribedNodes=null!==(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(key))&&void 0!==_graph$nodeToNodeSubs?_graph$nodeToNodeSubs:emptySet;for(const downstreamNode of subscribedNodes)visitedNodes.has(downstreamNode)||visitingNodes.push(downstreamNode)}return visitedNodes}var Recoil_FunctionalCore={getNodeLoadable:function(store,state,key){return initializeNodeIfNewToStore(store,state,key,"get"),getNode$1(key).get(store,state)},peekNodeLoadable:peekNodeLoadable,setNodeValue:function(store,state,key,newValue){const node=getNode$1(key);if(null==node.set)throw new ReadOnlyRecoilValueError("Attempt to set read-only RecoilValue: "+key);const set=node.set;return initializeNodeIfNewToStore(store,state,key,"set"),set(store,state,newValue)},cleanUpNode:function(store,key){var _state$nodeCleanupFun;const state=store.getState();null===(_state$nodeCleanupFun=state.nodeCleanupFunctions.get(key))||void 0===_state$nodeCleanupFun||_state$nodeCleanupFun(),state.nodeCleanupFunctions.delete(key)},setUnvalidatedAtomValue_DEPRECATED:function(state,key,newValue){var _node$invalidate;const node=getNodeMaybe$1(key);return null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),{...state,atomValues:state.atomValues.clone().delete(key),nonvalidatedAtoms:state.nonvalidatedAtoms.clone().set(key,newValue),dirtyAtoms:setByAddingToSet$1(state.dirtyAtoms,key)}},peekNodeInfo:function(store,state,key){var _graph$nodeDeps$get,_storeState$nodeToCom,_storeState$nodeToCom2;const storeState=store.getState(),graph=store.getGraph(state.version),type=storeState.knownAtoms.has(key)?"atom":storeState.knownSelectors.has(key)?"selector":void 0,downstreamNodes=Recoil_filterIterable(getDownstreamNodes(store,state,new Set([key])),nodeKey=>nodeKey!==key);return{loadable:peekNodeLoadable(store,state,key),isActive:storeState.knownAtoms.has(key)||storeState.knownSelectors.has(key),isSet:"selector"!==type&&state.atomValues.has(key),isModified:state.dirtyAtoms.has(key),type:type,deps:recoilValuesForKeys$1(null!==(_graph$nodeDeps$get=graph.nodeDeps.get(key))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:[]),subscribers:{nodes:recoilValuesForKeys$1(downstreamNodes),components:Recoil_mapIterable(null!==(_storeState$nodeToCom=null===(_storeState$nodeToCom2=storeState.nodeToComponentSubscriptions.get(key))||void 0===_storeState$nodeToCom2?void 0:_storeState$nodeToCom2.values())&&void 0!==_storeState$nodeToCom?_storeState$nodeToCom:[],([name])=>({name:name}))}}},getDownstreamNodes:getDownstreamNodes,initializeNodeIfNewToStore:initializeNodeIfNewToStore};const{getDownstreamNodes:getDownstreamNodes$1,getNodeLoadable:getNodeLoadable$1,setNodeValue:setNodeValue$1}=Recoil_FunctionalCore,{getNodeMaybe:getNodeMaybe$2}=Recoil_Node,{DefaultValue:DefaultValue$1,RecoilValueNotReady:RecoilValueNotReady$1}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,RecoilValueReadOnly:RecoilValueReadOnly$1,isRecoilValue:isRecoilValue$1}=Recoil_RecoilValue$1;function applyAction(store,state,action){if("set"===action.type){const{recoilValue:recoilValue,valueOrUpdater:valueOrUpdater}=action,newValue=function(store,state,{key:key},valueOrUpdater){if("function"==typeof valueOrUpdater){const current=getNodeLoadable$1(store,state,key);if("loading"===current.state)throw new RecoilValueNotReady$1(key);if("hasError"===current.state)throw current.contents;return valueOrUpdater(current.contents)}return valueOrUpdater}(store,state,recoilValue,valueOrUpdater),writes=setNodeValue$1(store,state,recoilValue.key,newValue);for(const[key,loadable]of writes.entries())writeLoadableToTreeState(state,key,loadable)}else if("setLoadable"===action.type){const{recoilValue:{key:key},loadable:loadable}=action;writeLoadableToTreeState(state,key,loadable)}else if("markModified"===action.type){const{recoilValue:{key:key}}=action;state.dirtyAtoms.add(key)}else if("setUnvalidated"===action.type){var _node$invalidate;const{recoilValue:{key:key},unvalidatedValue:unvalidatedValue}=action,node=getNodeMaybe$2(key);null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),state.atomValues.delete(key),state.nonvalidatedAtoms.set(key,unvalidatedValue),state.dirtyAtoms.add(key)}else Recoil_recoverableViolation("Unknown action "+action.type)}function writeLoadableToTreeState(state,key,loadable){"hasValue"===loadable.state&&loadable.contents instanceof DefaultValue$1?state.atomValues.delete(key):state.atomValues.set(key,loadable),state.dirtyAtoms.add(key),state.nonvalidatedAtoms.delete(key)}function applyActionsToStore(store,actions){store.replaceState(state=>{const newState=function(state){return{...state,atomValues:state.atomValues.clone(),nonvalidatedAtoms:state.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(state.dirtyAtoms)}}(state);for(const action of actions)applyAction(store,newState,action);return invalidateDownstreams(store,newState),newState})}function queueOrPerformStateUpdate(store,action){if(batchStack.length){const actionsByStore=batchStack[batchStack.length-1];let actions=actionsByStore.get(store);actions||actionsByStore.set(store,actions=[]),actions.push(action)}else applyActionsToStore(store,[action])}const batchStack=[];function invalidateDownstreams(store,state){const downstreams=getDownstreamNodes$1(store,state,state.dirtyAtoms);for(const key of downstreams){var _getNodeMaybe,_getNodeMaybe$invalid;null===(_getNodeMaybe=getNodeMaybe$2(key))||void 0===_getNodeMaybe||null===(_getNodeMaybe$invalid=_getNodeMaybe.invalidate)||void 0===_getNodeMaybe$invalid||_getNodeMaybe$invalid.call(_getNodeMaybe,state)}}function setRecoilValue(store,recoilValue,valueOrUpdater){queueOrPerformStateUpdate(store,{type:"set",recoilValue:recoilValue,valueOrUpdater:valueOrUpdater})}let subscriptionID=0;var Recoil_RecoilValueInterface={RecoilValueReadOnly:RecoilValueReadOnly$1,AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,getRecoilValueAsLoadable:function(store,{key:key},treeState=store.getState().currentTree){var _storeState$nextTree,_storeState$previousT;const storeState=store.getState();return treeState.version!==storeState.currentTree.version&&treeState.version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&(treeState.version,null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT||_storeState$previousT.version),getNodeLoadable$1(store,treeState,key)},setRecoilValue:setRecoilValue,setRecoilValueLoadable:function(store,recoilValue,loadable){if(loadable instanceof DefaultValue$1)return setRecoilValue(store,recoilValue,loadable);queueOrPerformStateUpdate(store,{type:"setLoadable",recoilValue:recoilValue,loadable:loadable})},markRecoilValueModified:function(store,recoilValue){queueOrPerformStateUpdate(store,{type:"markModified",recoilValue:recoilValue})},setUnvalidatedRecoilValue:function(store,recoilValue,unvalidatedValue){queueOrPerformStateUpdate(store,{type:"setUnvalidated",recoilValue:recoilValue,unvalidatedValue:unvalidatedValue})},subscribeToRecoilValue:function(store,{key:key},callback,componentDebugName=null){const subID=subscriptionID++,storeState=store.getState();return storeState.nodeToComponentSubscriptions.has(key)||storeState.nodeToComponentSubscriptions.set(key,new Map),Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID,[null!=componentDebugName?componentDebugName:"<not captured>",callback]),{release:()=>{const storeState=store.getState(),subs=storeState.nodeToComponentSubscriptions.get(key);void 0!==subs&&subs.has(subID)&&(subs.delete(subID),0===subs.size&&storeState.nodeToComponentSubscriptions.delete(key))}}},isRecoilValue:isRecoilValue$1,applyAtomValueWrites:function(atomValues,writes){const result=atomValues.clone();return writes.forEach((v,k)=>{"hasValue"===v.state&&v.contents instanceof DefaultValue$1?result.delete(k):result.set(k,v)}),result},batchStart:function(){const actionsByStore=new Map;return batchStack.push(actionsByStore),()=>{for(const[store,actions]of actionsByStore)applyActionsToStore(store,actions);batchStack.pop()}},invalidateDownstreams_FOR_TESTING:invalidateDownstreams};const{unstable_batchedUpdates:unstable_batchedUpdates}=reactDom;var ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates};const{unstable_batchedUpdates:unstable_batchedUpdates$1}=ReactBatchedUpdates;var Recoil_ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates$1};const{batchStart:batchStart$1}=Recoil_RecoilValueInterface,{unstable_batchedUpdates:unstable_batchedUpdates$2}=Recoil_ReactBatchedUpdates;let batcher=unstable_batchedUpdates$2;var Recoil_Batching={getBatcher:()=>batcher,setBatcher:newBatcher=>{batcher=newBatcher},batchUpdates:callback=>{batcher(()=>{let batchEnd=()=>{};try{batchEnd=batchStart$1(),callback()}finally{batchEnd()}})}};var Recoil_Queue={enqueueExecution:function(s,f){f()}};var Recoil_differenceSets=function(set,...setsWithValuesToRemove){const ret=new Set;FIRST:for(const value of set){for(const otherSet of setsWithValuesToRemove)if(otherSet.has(value))continue FIRST;ret.add(value)}return ret};var Recoil_mapMap=function(map,callback){const result=new Map;return map.forEach((value,key)=>{result.set(key,callback(value,key))}),result};function mergeDependencyMapIntoGraph(deps,graph,olderGraph){const{nodeDeps:nodeDeps,nodeToNodeSubscriptions:nodeToNodeSubscriptions}=graph;deps.forEach((upstreams,downstream)=>{const existingUpstreams=nodeDeps.get(downstream);if(existingUpstreams&&olderGraph&&existingUpstreams!==olderGraph.nodeDeps.get(downstream))return;nodeDeps.set(downstream,new Set(upstreams));if((null==existingUpstreams?upstreams:Recoil_differenceSets(upstreams,existingUpstreams)).forEach(upstream=>{nodeToNodeSubscriptions.has(upstream)||nodeToNodeSubscriptions.set(upstream,new Set);Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream)).add(downstream)}),existingUpstreams){Recoil_differenceSets(existingUpstreams,upstreams).forEach(upstream=>{if(!nodeToNodeSubscriptions.has(upstream))return;const existing=Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream));existing.delete(downstream),0===existing.size&&nodeToNodeSubscriptions.delete(upstream)})}})}var Recoil_Graph={addToDependencyMap:function(downstream,upstream,dependencyMap){dependencyMap.has(downstream)||dependencyMap.set(downstream,new Set),Recoil_nullthrows(dependencyMap.get(downstream)).add(upstream)},cloneGraph:function(graph){return{nodeDeps:Recoil_mapMap(graph.nodeDeps,s=>new Set(s)),nodeToNodeSubscriptions:Recoil_mapMap(graph.nodeToNodeSubscriptions,s=>new Set(s))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(from,into){from.forEach((upstreamDeps,downstreamNode)=>{into.has(downstreamNode)||into.set(downstreamNode,new Set);const deps=Recoil_nullthrows(into.get(downstreamNode));upstreamDeps.forEach(dep=>deps.add(dep))})},saveDependencyMapToStore:function(dependencyMap,store,version){var _storeState$nextTree,_storeState$previousT,_storeState$previousT2,_storeState$previousT3;const storeState=store.getState();version!==storeState.currentTree.version&&version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT||_storeState$previousT.version);const graph=store.getGraph(version);if(mergeDependencyMapIntoGraph(dependencyMap,graph),version===(null===(_storeState$previousT2=storeState.previousTree)||void 0===_storeState$previousT2?void 0:_storeState$previousT2.version)){mergeDependencyMapIntoGraph(dependencyMap,store.getGraph(storeState.currentTree.version),graph)}if(version===(null===(_storeState$previousT3=storeState.previousTree)||void 0===_storeState$previousT3?void 0:_storeState$previousT3.version)||version===storeState.currentTree.version){var _storeState$nextTree2;const nextVersion=null===(_storeState$nextTree2=storeState.nextTree)||void 0===_storeState$nextTree2?void 0:_storeState$nextTree2.version;if(void 0!==nextVersion){mergeDependencyMapIntoGraph(dependencyMap,store.getGraph(nextVersion),graph)}}}};var hamt_1=function(fn,module){return fn(module={exports:{}},module.exports),module.exports}((function(module){var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},hamt={},BUCKET_SIZE=Math.pow(2,5),MASK=BUCKET_SIZE-1,MAX_INDEX_NODE=BUCKET_SIZE/2,MIN_ARRAY_NODE=BUCKET_SIZE/4,nothing={},constant=function(x){return function(){return x}},hash=hamt.hash=function(str){var type=void 0===str?"undefined":_typeof(str);if("number"===type)return str;"string"!==type&&(str+="");for(var hash=0,i=0,len=str.length;i<len;++i){hash=(hash<<5)-hash+str.charCodeAt(i)|0}return hash},hashFragment=function(shift,h){return h>>>shift&MASK},toBitmap=function(x){return 1<<x},fromBitmap=function(bitmap,bit){return x=bitmap&bit-1,x=(x=(858993459&(x-=x>>1&1431655765))+(x>>2&858993459))+(x>>4)&252645135,x+=x>>8,127&(x+=x>>16);var x},arrayUpdate=function(mutate,at,v,arr){var out=arr;if(!mutate){var len=arr.length;out=new Array(len);for(var i=0;i<len;++i)out[i]=arr[i]}return out[at]=v,out},arraySpliceOut=function(mutate,at,arr){var newLen=arr.length-1,i=0,g=0,out=arr;if(mutate)i=g=at;else for(out=new Array(newLen);i<at;)out[g++]=arr[i++];for(++i;i<=newLen;)out[g++]=arr[i++];return mutate&&(out.length=newLen),out},empty={__hamt_isEmpty:!0},isEmptyNode=function(x){return x===empty||x&&x.__hamt_isEmpty},Leaf=function(edit,hash,key,value){return{type:1,edit:edit,hash:hash,key:key,value:value,_modify:Leaf__modify}},Collision=function(edit,hash,children){return{type:2,edit:edit,hash:hash,children:children,_modify:Collision__modify}},IndexedNode=function(edit,mask,children){return{type:3,edit:edit,mask:mask,children:children,_modify:IndexedNode__modify}},ArrayNode=function(edit,size,children){return{type:4,edit:edit,size:size,children:children,_modify:ArrayNode__modify}},mergeLeaves=function mergeLeaves(edit,shift,h1,n1,h2,n2){if(h1===h2)return Collision(edit,h1,[n2,n1]);var subH1=hashFragment(shift,h1),subH2=hashFragment(shift,h2);return IndexedNode(edit,toBitmap(subH1)|toBitmap(subH2),subH1===subH2?[mergeLeaves(edit,shift+5,h1,n1,h2,n2)]:subH1<subH2?[n1,n2]:[n2,n1])},canEditNode=function(edit,node){return edit===node.edit},Leaf__modify=function(edit,keyEq,shift,f,h,k,size){if(keyEq(k,this.key)){var _v=f(this.value);return _v===this.value?this:_v===nothing?(--size.value,empty):canEditNode(edit,this)?(this.value=_v,this):Leaf(edit,h,k,_v)}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},Collision__modify=function(edit,keyEq,shift,f,h,k,size){if(h===this.hash){var list=function(mutate,edit,keyEq,h,list,f,k,size){for(var len=list.length,i=0;i<len;++i){var child=list[i];if(keyEq(k,child.key)){var value=child.value,_newValue=f(value);return _newValue===value?list:_newValue===nothing?(--size.value,arraySpliceOut(mutate,i,list)):arrayUpdate(mutate,i,Leaf(edit,h,k,_newValue),list)}}var newValue=f();return newValue===nothing?list:(++size.value,arrayUpdate(mutate,len,Leaf(edit,h,k,newValue),list))}(canEditNode(edit,this),edit,keyEq,this.hash,this.children,f,k,size);return list===this.children?this:list.length>1?Collision(edit,this.hash,list):list[0]}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},IndexedNode__modify=function(edit,keyEq,shift,f,h,k,size){var mask=this.mask,children=this.children,frag=hashFragment(shift,h),bit=toBitmap(frag),indx=fromBitmap(mask,bit),exists=mask&bit,current=exists?children[indx]:empty,child=current._modify(edit,keyEq,shift+5,f,h,k,size);if(current===child)return this;var node,canEdit=canEditNode(edit,this),bitmap=mask,newChildren=void 0;if(exists&&isEmptyNode(child)){if(!(bitmap&=~bit))return empty;if(children.length<=2&&((node=children[1^indx])===empty||1===node.type||2===node.type))return children[1^indx];newChildren=arraySpliceOut(canEdit,indx,children)}else if(exists||isEmptyNode(child))newChildren=arrayUpdate(canEdit,indx,child,children);else{if(children.length>=MAX_INDEX_NODE)return function(edit,frag,child,bitmap,subNodes){for(var arr=[],bit=bitmap,count=0,i=0;bit;++i)1&bit&&(arr[i]=subNodes[count++]),bit>>>=1;return arr[frag]=child,ArrayNode(edit,count+1,arr)}(edit,frag,child,mask,children);bitmap|=bit,newChildren=function(mutate,at,v,arr){var len=arr.length;if(mutate){for(var _i=len;_i>=at;)arr[_i--]=arr[_i];return arr[at]=v,arr}for(var i=0,g=0,out=new Array(len+1);i<at;)out[g++]=arr[i++];for(out[at]=v;i<len;)out[++g]=arr[i++];return out}(canEdit,indx,child,children)}return canEdit?(this.mask=bitmap,this.children=newChildren,this):IndexedNode(edit,bitmap,newChildren)},ArrayNode__modify=function(edit,keyEq,shift,f,h,k,size){var count=this.size,children=this.children,frag=hashFragment(shift,h),child=children[frag],newChild=(child||empty)._modify(edit,keyEq,shift+5,f,h,k,size);if(child===newChild)return this;var canEdit=canEditNode(edit,this),newChildren=void 0;if(isEmptyNode(child)&&!isEmptyNode(newChild))++count,newChildren=arrayUpdate(canEdit,frag,newChild,children);else if(!isEmptyNode(child)&&isEmptyNode(newChild)){if(--count<=MIN_ARRAY_NODE)return function(edit,count,removed,elements){for(var children=new Array(count-1),g=0,bitmap=0,i=0,len=elements.length;i<len;++i)if(i!==removed){var elem=elements[i];elem&&!isEmptyNode(elem)&&(children[g++]=elem,bitmap|=1<<i)}return IndexedNode(edit,bitmap,children)}(edit,count,frag,children);newChildren=arrayUpdate(canEdit,frag,empty,children)}else newChildren=arrayUpdate(canEdit,frag,newChild,children);return canEdit?(this.size=count,this.children=newChildren,this):ArrayNode(edit,count,newChildren)};function Map(editable,edit,config,root,size){this._editable=editable,this._edit=edit,this._config=config,this._root=root,this._size=size}empty._modify=function(edit,keyEq,shift,f,h,k,size){var v=f();return v===nothing?empty:(++size.value,Leaf(edit,h,k,v))},Map.prototype.setTree=function(newRoot,newSize){return this._editable?(this._root=newRoot,this._size=newSize,this):newRoot===this._root?this:new Map(this._editable,this._edit,this._config,newRoot,newSize)};var tryGetHash=hamt.tryGetHash=function(alt,hash,key,map){for(var node=map._root,shift=0,keyEq=map._config.keyEq;;)switch(node.type){case 1:return keyEq(key,node.key)?node.value:alt;case 2:if(hash===node.hash)for(var children=node.children,i=0,len=children.length;i<len;++i){var child=children[i];if(keyEq(key,child.key))return child.value}return alt;case 3:var frag=hashFragment(shift,hash),bit=toBitmap(frag);if(node.mask&bit){node=node.children[fromBitmap(node.mask,bit)],shift+=5;break}return alt;case 4:if(node=node.children[hashFragment(shift,hash)]){shift+=5;break}return alt;default:return alt}};Map.prototype.tryGetHash=function(alt,hash,key){return tryGetHash(alt,hash,key,this)};var tryGet=hamt.tryGet=function(alt,key,map){return tryGetHash(alt,map._config.hash(key),key,map)};Map.prototype.tryGet=function(alt,key){return tryGet(alt,key,this)};var getHash=hamt.getHash=function(hash,key,map){return tryGetHash(void 0,hash,key,map)};Map.prototype.getHash=function(hash,key){return getHash(hash,key,this)};hamt.get=function(key,map){return tryGetHash(void 0,map._config.hash(key),key,map)};Map.prototype.get=function(key,alt){return tryGet(alt,key,this)};var hasHash=hamt.has=function(hash,key,map){return tryGetHash(nothing,hash,key,map)!==nothing};Map.prototype.hasHash=function(hash,key){return hasHash(hash,key,this)};var has=hamt.has=function(key,map){return hasHash(map._config.hash(key),key,map)};Map.prototype.has=function(key){return has(key,this)};var defKeyCompare=function(x,y){return x===y};hamt.make=function(config){return new Map(0,0,{keyEq:config&&config.keyEq||defKeyCompare,hash:config&&config.hash||hash},empty,0)},hamt.empty=hamt.make();var isEmpty=hamt.isEmpty=function(map){return map&&!!isEmptyNode(map._root)};Map.prototype.isEmpty=function(){return isEmpty(this)};var modifyHash=hamt.modifyHash=function(f,hash,key,map){var size={value:map._size},newRoot=map._root._modify(map._editable?map._edit:NaN,map._config.keyEq,0,f,hash,key,size);return map.setTree(newRoot,size.value)};Map.prototype.modifyHash=function(hash,key,f){return modifyHash(f,hash,key,this)};var modify=hamt.modify=function(f,key,map){return modifyHash(f,map._config.hash(key),key,map)};Map.prototype.modify=function(key,f){return modify(f,key,this)};var setHash=hamt.setHash=function(hash,key,value,map){return modifyHash(constant(value),hash,key,map)};Map.prototype.setHash=function(hash,key,value){return setHash(hash,key,value,this)};var set=hamt.set=function(key,value,map){return setHash(map._config.hash(key),key,value,map)};Map.prototype.set=function(key,value){return set(key,value,this)};var del=constant(nothing),removeHash=hamt.removeHash=function(hash,key,map){return modifyHash(del,hash,key,map)};Map.prototype.removeHash=Map.prototype.deleteHash=function(hash,key){return removeHash(hash,key,this)};var remove=hamt.remove=function(key,map){return removeHash(map._config.hash(key),key,map)};Map.prototype.remove=Map.prototype.delete=function(key){return remove(key,this)};var beginMutation=hamt.beginMutation=function(map){return new Map(map._editable+1,map._edit+1,map._config,map._root,map._size)};Map.prototype.beginMutation=function(){return beginMutation(this)};var endMutation=hamt.endMutation=function(map){return map._editable=map._editable&&map._editable-1,map};Map.prototype.endMutation=function(){return endMutation(this)};var mutate=hamt.mutate=function(f,map){var transient=beginMutation(map);return f(transient),endMutation(transient)};Map.prototype.mutate=function(f){return mutate(f,this)};var appk=function(k){return k&&lazyVisitChildren(k[0],k[1],k[2],k[3],k[4])},lazyVisitChildren=function(len,children,i,f,k){for(;i<len;){var child=children[i++];if(child&&!isEmptyNode(child))return lazyVisit(child,f,[len,children,i,f,k])}return appk(k)},lazyVisit=function(node,f,k){switch(node.type){case 1:return{value:f(node),rest:k};case 2:case 4:case 3:var children=node.children;return lazyVisitChildren(children.length,children,0,f,k);default:return appk(k)}},DONE={done:!0};function MapIterator(v){this.v=v}MapIterator.prototype.next=function(){if(!this.v)return DONE;var v0=this.v;return this.v=appk(v0.rest),v0},MapIterator.prototype[Symbol.iterator]=function(){return this};var visit=function(map,f){return new MapIterator(lazyVisit(map._root,f))},buildPairs=function(x){return[x.key,x.value]},entries=hamt.entries=function(map){return visit(map,buildPairs)};Map.prototype.entries=Map.prototype[Symbol.iterator]=function(){return entries(this)};var buildKeys=function(x){return x.key},keys=hamt.keys=function(map){return visit(map,buildKeys)};Map.prototype.keys=function(){return keys(this)};var buildValues=function(x){return x.value},values=hamt.values=Map.prototype.values=function(map){return visit(map,buildValues)};Map.prototype.values=function(){return values(this)};var fold=hamt.fold=function(f,z,m){var root=m._root;if(1===root.type)return f(z,root.value,root.key);for(var toVisit=[root.children],children=void 0;children=toVisit.pop();)for(var i=0,len=children.length;i<len;){var child=children[i++];child&&child.type&&(1===child.type?z=f(z,child.value,child.key):toVisit.push(child.children))}return z};Map.prototype.fold=function(f,z){return fold(f,z,this)};var forEach=hamt.forEach=function(f,map){return fold((function(_,value,key){return f(value,key,map)}),null,map)};Map.prototype.forEach=function(f){return forEach(f,this)};var count=hamt.count=function(map){return map._size};Map.prototype.count=function(){return count(this)},Object.defineProperty(Map.prototype,"size",{get:Map.prototype.count}),module.exports?module.exports=hamt:(void 0).hamt=hamt}));class BuiltInMap{constructor(existing){_defineProperty(this,"_map",void 0),this._map=new Map(null==existing?void 0:existing.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(k){return this._map.get(k)}has(k){return this._map.has(k)}set(k,v){return this._map.set(k,v),this}delete(k){return this._map.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._map)}}class HashArrayMappedTrieMap{constructor(existing){if(_defineProperty(this,"_hamt",hamt_1.empty.beginMutation()),existing instanceof HashArrayMappedTrieMap){const h=existing._hamt.endMutation();existing._hamt=h.beginMutation(),this._hamt=h.beginMutation()}else if(existing)for(const[k,v]of existing.entries())this._hamt.set(k,v)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(k){return this._hamt.get(k)}has(k){return this._hamt.has(k)}set(k,v){return this._hamt.set(k,v),this}delete(k){return this._hamt.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._hamt)}}function persistentMap(existing){return Recoil_gkx_1("recoil_hamt_2020")?new HashArrayMappedTrieMap(existing):new BuiltInMap(existing)}var Recoil_PersistentMap_1=persistentMap,Recoil_PersistentMap$1=Object.freeze({__proto__:null,persistentMap:Recoil_PersistentMap_1});const{graph:graph$1}=Recoil_Graph,{persistentMap:persistentMap$1}=Recoil_PersistentMap$1;let nextTreeStateVersion=0;const getNextTreeStateVersion=()=>nextTreeStateVersion++;function makeEmptyTreeState(){const version=getNextTreeStateVersion();return{version:version,stateID:version,transactionMetadata:{},dirtyAtoms:new Set,atomValues:persistentMap$1(),nonvalidatedAtoms:persistentMap$1()}}var Recoil_State={makeEmptyTreeState:makeEmptyTreeState,makeEmptyStoreState:function(){const currentTree=makeEmptyTreeState();return{currentTree:currentTree,nextTree:null,previousTree:null,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(currentTree.version,graph$1()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:getNextTreeStateVersion};var Recoil_unionSets=function(...sets){const result=new Set;for(const set of sets)for(const value of set)result.add(value);return result};var Recoil_someSet=function(set,callback,context){const iterator=set.entries();let current=iterator.next();for(;!current.done;){const entry=current.value;if(callback.call(context,entry[1],entry[0],set))return!0;current=iterator.next()}return!1};const{cleanUpNode:cleanUpNode$1}=Recoil_FunctionalCore,{deleteNodeConfigIfPossible:deleteNodeConfigIfPossible$1,getNode:getNode$2}=Recoil_Node,{RetentionZone:RetentionZone$2}=Recoil_RetentionZone,emptySet$1=new Set;function releaseRetainablesNowOnCurrentTree(store,retainables){const storeState=store.getState(),treeState=storeState.currentTree;if(storeState.nextTree)return;const nodes=new Set;for(const r of retainables)if(r instanceof RetentionZone$2)for(const n of nodesRetainedByZone(storeState,r))nodes.add(n);else nodes.add(r);const releasableNodes=function(store,searchFromNodes){const storeState=store.getState(),treeState=storeState.currentTree,graph=store.getGraph(treeState.version),releasableNodes=new Set,nonReleasableNodes=new Set;return findReleasableNodesInner(searchFromNodes),releasableNodes;function findReleasableNodesInner(searchFromNodes){const releasableNodesFoundThisIteration=new Set,downstreams=function(store,treeState,nodes,doNotDescendInto1,doNotDescendInto2){const graph=store.getGraph(treeState.version),answer=[],visited=new Set;for(;nodes.size>0;)visit(Recoil_nullthrows(nodes.values().next().value));return answer;function visit(node){if(doNotDescendInto1.has(node)||doNotDescendInto2.has(node))return void nodes.delete(node);if(visited.has(node))return;const children=graph.nodeToNodeSubscriptions.get(node);if(children)for(const child of children)visit(child);visited.add(node),nodes.delete(node),answer.push(node)}}(store,treeState,searchFromNodes,releasableNodes,nonReleasableNodes);for(const node of downstreams){var _storeState$retention;if("recoilRoot"===getNode$2(node).retainedBy){nonReleasableNodes.add(node);continue}if((null!==(_storeState$retention=storeState.retention.referenceCounts.get(node))&&void 0!==_storeState$retention?_storeState$retention:0)>0){nonReleasableNodes.add(node);continue}if(zonesThatCouldRetainNode(node).some(z=>storeState.retention.referenceCounts.get(z))){nonReleasableNodes.add(node);continue}const nodeChildren=graph.nodeToNodeSubscriptions.get(node);nodeChildren&&Recoil_someSet(nodeChildren,child=>nonReleasableNodes.has(child))?nonReleasableNodes.add(node):(releasableNodes.add(node),releasableNodesFoundThisIteration.add(node))}const parents=new Set;for(const node of releasableNodesFoundThisIteration)for(const parent of null!==(_graph$nodeDeps$get=graph.nodeDeps.get(node))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:emptySet$1){var _graph$nodeDeps$get;releasableNodes.has(parent)||parents.add(parent)}parents.size&&findReleasableNodesInner(parents)}}(store,nodes);for(const node of releasableNodes)releaseNode(store,treeState,node)}function releaseNode(store,treeState,node){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;cleanUpNode$1(store,node);const storeState=store.getState();storeState.knownAtoms.delete(node),storeState.knownSelectors.delete(node),storeState.nodeTransactionSubscriptions.delete(node),storeState.retention.referenceCounts.delete(node);const zones=zonesThatCouldRetainNode(node);for(const zone of zones){var _storeState$retention2;null===(_storeState$retention2=storeState.retention.nodesRetainedByZone.get(zone))||void 0===_storeState$retention2||_storeState$retention2.delete(node)}treeState.atomValues.delete(node),treeState.dirtyAtoms.delete(node),treeState.nonvalidatedAtoms.delete(node);const graph=storeState.graphsByVersion.get(treeState.version);if(graph){const deps=graph.nodeDeps.get(node);if(void 0!==deps){graph.nodeDeps.delete(node);for(const dep of deps){var _graph$nodeToNodeSubs;null===(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(dep))||void 0===_graph$nodeToNodeSubs||_graph$nodeToNodeSubs.delete(node)}}graph.nodeToNodeSubscriptions.delete(node)}deleteNodeConfigIfPossible$1(node)}function nodesRetainedByZone(storeState,zone){var _storeState$retention3;return null!==(_storeState$retention3=storeState.retention.nodesRetainedByZone.get(zone))&&void 0!==_storeState$retention3?_storeState$retention3:emptySet$1}function zonesThatCouldRetainNode(node){const retainedBy=getNode$2(node).retainedBy;return void 0===retainedBy||"components"===retainedBy||"recoilRoot"===retainedBy?[]:retainedBy instanceof RetentionZone$2?[retainedBy]:retainedBy}var Recoil_Retention={updateRetainCount:function(store,retainable,delta){var _map$get;if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const map=store.getState().retention.referenceCounts,newCount=(null!==(_map$get=map.get(retainable))&&void 0!==_map$get?_map$get:0)+delta;0===newCount?(map.delete(retainable),function(store,retainable){const state=store.getState();state.nextTree?state.retention.retainablesToCheckForRelease.add(retainable):releaseRetainablesNowOnCurrentTree(store,new Set([retainable]))}(store,retainable)):map.set(retainable,newCount)},releaseScheduledRetainablesNow:function(store){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const state=store.getState();releaseRetainablesNowOnCurrentTree(store,state.retention.retainablesToCheckForRelease),state.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(r){return void 0===r?"recoilRoot":r}};var Recoil_concatIterables=function*(iters){for(const iter of iters)for(const val of iter)yield val};var Recoil_Environment={isSSR:"undefined"==typeof window,isReactNative:"undefined"!=typeof navigator&&"ReactNative"===navigator.product};const{isSSR:isSSR$1}=Recoil_Environment,{batchUpdates:batchUpdates$1}=Recoil_Batching,{initializeNodeIfNewToStore:initializeNodeIfNewToStore$1,peekNodeInfo:peekNodeInfo$1}=Recoil_FunctionalCore,{graph:graph$2}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$1,recoilValues:recoilValues$1,recoilValuesForKeys:recoilValuesForKeys$2}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$2,getRecoilValueAsLoadable:getRecoilValueAsLoadable$1,setRecoilValue:setRecoilValue$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$1}=Recoil_RecoilValueInterface,{getNextTreeStateVersion:getNextTreeStateVersion$1,makeEmptyStoreState:makeEmptyStoreState$1}=Recoil_State;class Snapshot{constructor(storeState){_defineProperty(this,"_store",void 0),_defineProperty(this,"_refCount",0),_defineProperty(this,"getLoadable",recoilValue=>(this.checkRefCount_INTERNAL(),getRecoilValueAsLoadable$1(this._store,recoilValue))),_defineProperty(this,"getPromise",recoilValue=>(this.checkRefCount_INTERNAL(),this.getLoadable(recoilValue).toPromise())),_defineProperty(this,"getNodes_UNSTABLE",opt=>{if(this.checkRefCount_INTERNAL(),!0===(null==opt?void 0:opt.isModified)){if(!1===(null==opt?void 0:opt.isInitialized))return[];const state=this._store.getState().currentTree;return recoilValuesForKeys$2(state.dirtyAtoms)}const knownAtoms=this._store.getState().knownAtoms,knownSelectors=this._store.getState().knownSelectors;return null==(null==opt?void 0:opt.isInitialized)?recoilValues$1.values():!0===opt.isInitialized?recoilValuesForKeys$2(Recoil_concatIterables([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Recoil_filterIterable(recoilValues$1.values(),({key:key})=>!knownAtoms.has(key)&&!knownSelectors.has(key))}),_defineProperty(this,"getInfo_UNSTABLE",({key:key})=>(this.checkRefCount_INTERNAL(),peekNodeInfo$1(this._store,this._store.getState().currentTree,key))),_defineProperty(this,"map",mapper=>{this.checkRefCount_INTERNAL();const mutableSnapshot=new MutableSnapshot(this);return mapper(mutableSnapshot),cloneSnapshot(mutableSnapshot.getStore_INTERNAL())}),_defineProperty(this,"asyncMap",async mapper=>{this.checkRefCount_INTERNAL();const mutableSnapshot=new MutableSnapshot(this);return await mapper(mutableSnapshot),cloneSnapshot(mutableSnapshot.getStore_INTERNAL())}),this._store={getState:()=>storeState,replaceState:replacer=>{storeState.currentTree=replacer(storeState.currentTree)},getGraph:version=>{const graphs=storeState.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$2();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const nodeKey of this._store.getState().nodeCleanupFunctions.keys())initializeNodeIfNewToStore$1(this._store,storeState.currentTree,nodeKey,"get");this.retain(),this.autorelease()}retain(){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return()=>{};this._refCount++;let released=!1;return()=>{released||(released=!0,this.release())}}autorelease(){Recoil_gkx_1("recoil_memory_managament_2020")&&(isSSR$1||window.setTimeout(()=>this.release(),0))}release(){Recoil_gkx_1("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){Recoil_gkx_1("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function cloneStoreState(store,treeState,bumpVersion=!1){const storeState=store.getState(),version=bumpVersion?getNextTreeStateVersion$1():treeState.version;return{currentTree:bumpVersion?{version:version,stateID:version,transactionMetadata:{...treeState.transactionMetadata},dirtyAtoms:new Set(treeState.dirtyAtoms),atomValues:treeState.atomValues.clone(),nonvalidatedAtoms:treeState.nonvalidatedAtoms.clone()}:treeState,nextTree:null,previousTree:null,knownAtoms:new Set(storeState.knownAtoms),knownSelectors:new Set(storeState.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(version,store.getGraph(treeState.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function cloneSnapshot(store,version="current"){const storeState=store.getState(),treeState="current"===version?storeState.currentTree:Recoil_nullthrows(storeState.previousTree);return new Snapshot(cloneStoreState(store,treeState))}class MutableSnapshot extends Snapshot{constructor(snapshot){super(cloneStoreState(snapshot.getStore_INTERNAL(),snapshot.getStore_INTERNAL().getState().currentTree,!0)),_defineProperty(this,"set",(recoilState,newValueOrUpdater)=>{this.checkRefCount_INTERNAL(),batchUpdates$1(()=>{setRecoilValue$1(this.getStore_INTERNAL(),recoilState,newValueOrUpdater)})}),_defineProperty(this,"reset",recoilState=>{this.checkRefCount_INTERNAL(),batchUpdates$1(()=>setRecoilValue$1(this.getStore_INTERNAL(),recoilState,DEFAULT_VALUE$1))}),_defineProperty(this,"setUnvalidatedAtomValues_DEPRECATED",values=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();batchUpdates$1(()=>{for(const[k,v]of values.entries())setUnvalidatedRecoilValue$1(store,new AbstractRecoilValue$2(k),v)})})}}var Recoil_Snapshot={Snapshot:Snapshot,MutableSnapshot:MutableSnapshot,freshSnapshot:function(initializeState){const snapshot=new Snapshot(makeEmptyStoreState$1());return null!=initializeState?snapshot.map(initializeState):snapshot},cloneSnapshot:cloneSnapshot},Recoil_Snapshot_1=Recoil_Snapshot.Snapshot,Recoil_Snapshot_2=Recoil_Snapshot.MutableSnapshot,Recoil_Snapshot_3=Recoil_Snapshot.freshSnapshot,Recoil_Snapshot_4=Recoil_Snapshot.cloneSnapshot,Recoil_Snapshot$1=Object.freeze({__proto__:null,Snapshot:Recoil_Snapshot_1,MutableSnapshot:Recoil_Snapshot_2,freshSnapshot:Recoil_Snapshot_3,cloneSnapshot:Recoil_Snapshot_4});const{getNextTreeStateVersion:getNextTreeStateVersion$2,makeEmptyStoreState:makeEmptyStoreState$2}=Recoil_State,{cleanUpNode:cleanUpNode$2,getDownstreamNodes:getDownstreamNodes$2,setNodeValue:setNodeValue$2,setUnvalidatedAtomValue_DEPRECATED:setUnvalidatedAtomValue_DEPRECATED$1}=Recoil_FunctionalCore,{graph:graph$3}=Recoil_Graph,{cloneGraph:cloneGraph$1}=Recoil_Graph,{applyAtomValueWrites:applyAtomValueWrites$1}=Recoil_RecoilValueInterface,{releaseScheduledRetainablesNow:releaseScheduledRetainablesNow$1}=Recoil_Retention,{freshSnapshot:freshSnapshot$1}=Recoil_Snapshot$1,{useCallback:useCallback,useContext:useContext,useEffect:useEffect,useMemo:useMemo,useRef:useRef,useState:useState}=react;function notInAContext(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const defaultStore=Object.freeze({getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext});let stateReplacerIsBeingExecuted=!1;function startNextTreeIfNeeded(storeState){if(stateReplacerIsBeingExecuted)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");if(null===storeState.nextTree){const version=storeState.currentTree.version,nextVersion=getNextTreeStateVersion$2();storeState.nextTree={...storeState.currentTree,version:nextVersion,stateID:nextVersion,dirtyAtoms:new Set,transactionMetadata:{}},storeState.graphsByVersion.set(nextVersion,cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))))}}const AppContext=react.createContext({current:defaultStore}),useStoreRef=()=>useContext(AppContext),MutableSourceContext=react.createContext(null);function sendEndOfBatchNotifications(store){const storeState=store.getState(),treeState=storeState.currentTree,dirtyAtoms=treeState.dirtyAtoms;if(dirtyAtoms.size){for(const[key,subscriptions]of storeState.nodeTransactionSubscriptions)if(dirtyAtoms.has(key))for(const[_,subscription]of subscriptions)subscription(store);for(const[_,subscription]of storeState.transactionSubscriptions)subscription(store);const dependentNodes=getDownstreamNodes$2(store,treeState,dirtyAtoms);for(const key of dependentNodes){const comps=storeState.nodeToComponentSubscriptions.get(key);if(comps)for(const[_subID,[_debugName,callback]]of comps)callback(treeState)}storeState.suspendedComponentResolvers.forEach(cb=>cb())}storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb=>cb(treeState)),storeState.queuedComponentCallbacks_DEPRECATED.splice(0,storeState.queuedComponentCallbacks_DEPRECATED.length)}function Batcher({setNotifyBatcherOfChange:setNotifyBatcherOfChange}){const storeRef=useStoreRef(),[_,setState]=useState([]);return setNotifyBatcherOfChange(()=>setState({})),useEffect(()=>{Recoil_Queue.enqueueExecution("Batcher",()=>{const storeState=storeRef.current.getState(),{nextTree:nextTree}=storeState;if(null===nextTree)return;storeState.previousTree=storeState.currentTree,storeState.currentTree=nextTree,storeState.nextTree=null,sendEndOfBatchNotifications(storeRef.current);const discardedVersion=Recoil_nullthrows(storeState.previousTree).version;storeState.graphsByVersion.delete(discardedVersion),storeState.previousTree=null,Recoil_gkx_1("recoil_memory_managament_2020")&&releaseScheduledRetainablesNow$1(storeRef.current)})}),useEffect(()=>()=>{setNotifyBatcherOfChange(()=>{})},[setNotifyBatcherOfChange]),null}let nextID=0;var Recoil_RecoilRoot_react={useStoreRef:useStoreRef,useRecoilMutableSource:function(){return useContext(MutableSourceContext)},RecoilRoot:function({initializeState_DEPRECATED:initializeState_DEPRECATED,initializeState:initializeState,store_INTERNAL:storeProp,children:children}){var _createMutableSource;let storeState;const notifyBatcherOfChange=useRef(null),setNotifyBatcherOfChange=useCallback(x=>{notifyBatcherOfChange.current=x},[notifyBatcherOfChange]),createMutableSource=null!==(_createMutableSource=react.createMutableSource)&&void 0!==_createMutableSource?_createMutableSource:react.unstable_createMutableSource,store=null!=storeProp?storeProp:{getState:()=>storeState.current,replaceState:replacer=>{const storeState=storeRef.current.getState();startNextTreeIfNeeded(storeState);const nextTree=Recoil_nullthrows(storeState.nextTree);let replaced;try{stateReplacerIsBeingExecuted=!0,replaced=replacer(nextTree)}finally{stateReplacerIsBeingExecuted=!1}replaced!==nextTree&&(storeState.nextTree=replaced,Recoil_nullthrows(notifyBatcherOfChange.current)())},getGraph:version=>{const graphs=storeState.current.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$3();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:(callback,key)=>{if(null==key){const{transactionSubscriptions:transactionSubscriptions}=storeRef.current.getState(),id=nextID++;return transactionSubscriptions.set(id,callback),{release:()=>{transactionSubscriptions.delete(id)}}}{const{nodeTransactionSubscriptions:nodeTransactionSubscriptions}=storeRef.current.getState();nodeTransactionSubscriptions.has(key)||nodeTransactionSubscriptions.set(key,new Map);const id=nextID++;return Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id,callback),{release:()=>{const subs=nodeTransactionSubscriptions.get(key);subs&&(subs.delete(id),0===subs.size&&nodeTransactionSubscriptions.delete(key))}}}},addTransactionMetadata:metadata=>{startNextTreeIfNeeded(storeRef.current.getState());for(const k of Object.keys(metadata))Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k]=metadata[k]}},storeRef=useRef(store);storeState=useRef(null!=initializeState_DEPRECATED?function(store,initializeState){const initial=makeEmptyStoreState$2();return initializeState({set:(atom,value)=>{const state=initial.currentTree,writes=setNodeValue$2(store,state,atom.key,value),writtenNodes=new Set(writes.keys()),nonvalidatedAtoms=state.nonvalidatedAtoms.clone();for(const n of writtenNodes)nonvalidatedAtoms.delete(n);initial.currentTree={...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNodes),atomValues:applyAtomValueWrites$1(state.atomValues,writes),nonvalidatedAtoms:nonvalidatedAtoms}},setUnvalidatedAtomValues:atomValues=>{atomValues.forEach((v,k)=>{initial.currentTree=setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree,k,v)})}}),initial}(store,initializeState_DEPRECATED):null!=initializeState?function(initializeState){return freshSnapshot$1().map(initializeState).getStore_INTERNAL().getState()}(initializeState):makeEmptyStoreState$2());const mutableSource=useMemo(()=>createMutableSource?createMutableSource(storeState,()=>storeState.current.currentTree.version):null,[createMutableSource,storeState]);return useEffect(()=>()=>{for(const atomKey of storeRef.current.getState().knownAtoms)cleanUpNode$2(storeRef.current,atomKey)},[]),react.createElement(AppContext.Provider,{value:storeRef},react.createElement(MutableSourceContext.Provider,{value:mutableSource},react.createElement(Batcher,{setNotifyBatcherOfChange:setNotifyBatcherOfChange}),children))},sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications};var Recoil_filterMap=function(map,callback){const result=new Map;for(const[key,value]of map)callback(value,key)&&result.set(key,value);return result};var Recoil_filterSet=function(set,callback){const result=new Set;for(const value of set)callback(value)&&result.add(value);return result};var Recoil_invariant=function(condition,message){if(!condition)throw new Error(message)};var _useMutableSource,Recoil_mergeMaps=function(...maps){const result=new Map;for(let i=0;i<maps.length;i++){const iterator=maps[i].keys();let nextKey;for(;!(nextKey=iterator.next()).done;)result.set(nextKey.value,maps[i].get(nextKey.value))}return result};const useMutableSource=null!==(_useMutableSource=react.useMutableSource)&&void 0!==_useMutableSource?_useMutableSource:react.unstable_useMutableSource;var Recoil_mutableSource={mutableSourceExists:function(){return useMutableSource&&!("undefined"!=typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:useMutableSource};var Recoil_shallowArrayEqual=function(a,b){if(a===b)return!0;if(a.length!==b.length)return!1;for(let i=0,l=a.length;i<l;i++)if(a[i]!==b[i])return!1;return!0};const{useRef:useRef$1}=react;var Recoil_useComponentName=function(){return useRef$1(),"<component name not available>"};const{batchUpdates:batchUpdates$2}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$2,getNode:getNode$3,nodes:nodes$1}=Recoil_Node,{useRecoilMutableSource:useRecoilMutableSource$1,useStoreRef:useStoreRef$1}=Recoil_RecoilRoot_react,{AbstractRecoilValue:AbstractRecoilValue$3,getRecoilValueAsLoadable:getRecoilValueAsLoadable$2,setRecoilValue:setRecoilValue$2,setRecoilValueLoadable:setRecoilValueLoadable$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$2,subscribeToRecoilValue:subscribeToRecoilValue$1}=Recoil_RecoilValueInterface,{updateRetainCount:updateRetainCount$1}=Recoil_Retention,{RetentionZone:RetentionZone$3}=Recoil_RetentionZone,{Snapshot:Snapshot$1,cloneSnapshot:cloneSnapshot$1}=Recoil_Snapshot$1,{setByAddingToSet:setByAddingToSet$2}=Recoil_CopyOnWrite,{isSSR:isSSR$2}=Recoil_Environment,{mutableSourceExists:mutableSourceExists$1,useMutableSource:useMutableSource$1}=Recoil_mutableSource,{useCallback:useCallback$1,useEffect:useEffect$1,useMemo:useMemo$1,useRef:useRef$2,useState:useState$1}=react;function handleLoadable(loadable,atom,storeRef){if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){throw new Promise(resolve=>{storeRef.current.getState().suspendedComponentResolvers.add(resolve)})}throw"hasError"===loadable.state?loadable.contents:new Error(`Invalid value of loadable atom "${atom.key}"`)}function useRecoilValueLoadable(recoilValue){return Recoil_gkx_1("recoil_memory_managament_2020")&&useRetain(recoilValue),mutableSourceExists$1()?function(recoilValue){const storeRef=useStoreRef$1(),getLoadable=useCallback$1(()=>{const store=storeRef.current,treeState=store.getState().currentTree;return getRecoilValueAsLoadable$2(store,recoilValue,treeState)},[storeRef,recoilValue]),getLoadableWithTesting=useCallback$1(()=>getLoadable(),[getLoadable]),componentName=Recoil_useComponentName(),subscribe=useCallback$1((_storeState,callback)=>{const store=storeRef.current;return subscribeToRecoilValue$1(store,recoilValue,()=>{if(!Recoil_gkx_1("recoil_suppress_rerender_in_callback"))return callback();const newLoadable=getLoadable();prevLoadableRef.current.is(newLoadable)||callback()},componentName).release},[storeRef,recoilValue,componentName,getLoadable]),source=useRecoilMutableSource$1(),loadable=useMutableSource$1(source,getLoadableWithTesting,subscribe),prevLoadableRef=useRef$2(loadable);return useEffect$1(()=>{prevLoadableRef.current=loadable}),loadable}(recoilValue):function(recoilValue){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),componentName=Recoil_useComponentName();useEffect$1(()=>{const store=storeRef.current,storeState=store.getState(),subscription=subscribeToRecoilValue$1(store,recoilValue,_state=>{var _prevLoadableRef$curr;if(!Recoil_gkx_1("recoil_suppress_rerender_in_callback"))return forceUpdate([]);const newLoadable=getRecoilValueAsLoadable$2(store,recoilValue,store.getState().currentTree);(null===(_prevLoadableRef$curr=prevLoadableRef.current)||void 0===_prevLoadableRef$curr?void 0:_prevLoadableRef$curr.is(newLoadable))||forceUpdate(newLoadable)},componentName);if(storeState.nextTree)store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{prevLoadableRef.current=null,forceUpdate([])});else{var _prevLoadableRef$curr2;if(!Recoil_gkx_1("recoil_suppress_rerender_in_callback"))return forceUpdate([]);const newLoadable=getRecoilValueAsLoadable$2(store,recoilValue,store.getState().currentTree);(null===(_prevLoadableRef$curr2=prevLoadableRef.current)||void 0===_prevLoadableRef$curr2?void 0:_prevLoadableRef$curr2.is(newLoadable))||forceUpdate(newLoadable)}return subscription.release},[componentName,recoilValue,storeRef]);const loadable=getRecoilValueAsLoadable$2(storeRef.current,recoilValue),prevLoadableRef=useRef$2(loadable);return useEffect$1(()=>{prevLoadableRef.current=loadable}),loadable}(recoilValue)}function useRecoilValue(recoilValue){const storeRef=useStoreRef$1();return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}function useSetRecoilState(recoilState){const storeRef=useStoreRef$1();return useCallback$1(newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)},[storeRef,recoilState])}function useTransactionSubscription(callback){const storeRef=useStoreRef$1();useEffect$1(()=>storeRef.current.subscribeToTransactions(callback).release,[callback,storeRef])}function externallyVisibleAtomValuesInState(state){const atomValues=state.atomValues.toMap(),persistedAtomContentsValues=Recoil_mapMap(Recoil_filterMap(atomValues,(v,k)=>{const persistence=getNode$3(k).persistence_UNSTABLE;return null!=persistence&&"none"!==persistence.type&&"hasValue"===v.state}),v=>v.contents);return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(),persistedAtomContentsValues)}function usePrevious(value){const ref=useRef$2();return useEffect$1(()=>{ref.current=value}),ref.current}function useGotoRecoilSnapshot(){const storeRef=useStoreRef$1();return useCallback$1(snapshot=>{var _storeState$nextTree;const storeState=storeRef.current.getState(),prev=null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree,next=snapshot.getStore_INTERNAL().getState().currentTree;batchUpdates$2(()=>{const keysToUpdate=new Set;for(const keys of[prev.atomValues.keys(),next.atomValues.keys()])for(const key of keys){var _prev$atomValues$get,_next$atomValues$get;(null===(_prev$atomValues$get=prev.atomValues.get(key))||void 0===_prev$atomValues$get?void 0:_prev$atomValues$get.contents)!==(null===(_next$atomValues$get=next.atomValues.get(key))||void 0===_next$atomValues$get?void 0:_next$atomValues$get.contents)&&getNode$3(key).shouldRestoreFromSnapshots&&keysToUpdate.add(key)}keysToUpdate.forEach(key=>{setRecoilValueLoadable$1(storeRef.current,new AbstractRecoilValue$3(key),next.atomValues.has(key)?Recoil_nullthrows(next.atomValues.get(key)):DEFAULT_VALUE$2)}),storeRef.current.replaceState(state=>({...state,stateID:snapshot.getID_INTERNAL()}))})},[storeRef])}class Sentinel{}const SENTINEL=new Sentinel;function useRetain(toRetain){if(Recoil_gkx_1("recoil_memory_managament_2020"))return function(toRetain){const retainables=(Array.isArray(toRetain)?toRetain:[toRetain]).map(a=>a instanceof RetentionZone$3?a:a.key),storeRef=useStoreRef$1();useEffect$1(()=>{if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const store=storeRef.current;if(timeoutID.current&&!isSSR$2)window.clearTimeout(timeoutID.current),timeoutID.current=null;else for(const r of retainables)updateRetainCount$1(store,r,1);return()=>{for(const r of retainables)updateRetainCount$1(store,r,-1)}},[storeRef,...retainables]);const timeoutID=useRef$2(),previousRetainables=usePrevious(retainables);if(!(isSSR$2||void 0!==previousRetainables&&Recoil_shallowArrayEqual(previousRetainables,retainables))){const store=storeRef.current;for(const r of retainables)updateRetainCount$1(store,r,1);if(previousRetainables)for(const r of previousRetainables)updateRetainCount$1(store,r,-1);timeoutID.current&&window.clearTimeout(timeoutID.current),timeoutID.current=window.setTimeout(()=>{timeoutID.current=null;for(const r of retainables)updateRetainCount$1(store,r,-1)},12e4)}}(toRetain)}var Recoil_Hooks={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:useGotoRecoilSnapshot,useRecoilCallback:function(fn,deps){const storeRef=useStoreRef$1(),gotoSnapshot=useGotoRecoilSnapshot();return useCallback$1((...args)=>{function set(recoilState,newValueOrUpdater){setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}function reset(recoilState){setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}const snapshot=cloneSnapshot$1(storeRef.current);let ret=SENTINEL;return batchUpdates$2(()=>{const errMsg="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof fn)throw new Error(errMsg);const cb=fn({set:set,reset:reset,snapshot:snapshot,gotoSnapshot:gotoSnapshot});if("function"!=typeof cb)throw new Error(errMsg);ret=cb(...args)}),ret instanceof Sentinel&&Recoil_invariant(!1),ret},null!=deps?[...deps,storeRef]:void 0)},useRecoilInterface:function(){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),recoilValuesUsed=useRef$2(new Set);recoilValuesUsed.current=new Set;const previousSubscriptions=useRef$2(new Set),subscriptions=useRef$2(new Map),unsubscribeFrom=useCallback$1(key=>{const sub=subscriptions.current.get(key);sub&&(sub.release(),subscriptions.current.delete(key))},[subscriptions]),componentName=Recoil_useComponentName();return useEffect$1(()=>{const store=storeRef.current;function updateState(_state,key){subscriptions.current.has(key)&&forceUpdate([])}Recoil_differenceSets(recoilValuesUsed.current,previousSubscriptions.current).forEach(key=>{if(subscriptions.current.has(key))return;const sub=subscribeToRecoilValue$1(store,new AbstractRecoilValue$3(key),state=>{updateState(0,key)},componentName);subscriptions.current.set(key,sub);store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{updateState(store.getState(),key)}):updateState(store.getState(),key)}),Recoil_differenceSets(previousSubscriptions.current,recoilValuesUsed.current).forEach(key=>{unsubscribeFrom(key)}),previousSubscriptions.current=recoilValuesUsed.current}),useEffect$1(()=>{const subs=subscriptions.current;return()=>subs.forEach((_,key)=>unsubscribeFrom(key))},[unsubscribeFrom]),useMemo$1(()=>{function useSetRecoilState(recoilState){return newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}}function useRecoilValueLoadable(recoilValue){return recoilValuesUsed.current.has(recoilValue.key)||(recoilValuesUsed.current=setByAddingToSet$2(recoilValuesUsed.current,recoilValue.key)),getRecoilValueAsLoadable$2(storeRef.current,recoilValue)}function useRecoilValue(recoilValue){return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},getRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},getSetRecoilState:useSetRecoilState,getResetRecoilState:function(recoilState){return()=>setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}}},[recoilValuesUsed,storeRef])},useRecoilSnapshot:function(){const storeRef=useStoreRef$1(),[snapshot,setSnapshot]=useState$1(()=>cloneSnapshot$1(storeRef.current)),previousSnapshot=usePrevious(snapshot),timeoutID=useRef$2();return useEffect$1(()=>(timeoutID.current&&!isSSR$2&&window.clearTimeout(timeoutID.current),snapshot.retain()),[snapshot]),useTransactionSubscription(useCallback$1(store=>setSnapshot(cloneSnapshot$1(store)),[])),previousSnapshot===snapshot||isSSR$2||(timeoutID.current&&(null==previousSnapshot||previousSnapshot.release(),window.clearTimeout(timeoutID.current)),snapshot.retain(),timeoutID.current=window.setTimeout(()=>{snapshot.release(),timeoutID.current=null},12e4)),snapshot},useRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},useRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},useRecoilTransactionObserver:function(callback){useTransactionSubscription(useCallback$1(store=>{const snapshot=cloneSnapshot$1(store,"current"),previousSnapshot=cloneSnapshot$1(store,"previous");callback({snapshot:snapshot,previousSnapshot:previousSnapshot})},[callback]))},useRecoilValue:useRecoilValue,useRecoilValueLoadable:useRecoilValueLoadable,useRetain:useRetain,useResetRecoilState:function(recoilState){const storeRef=useStoreRef$1();return useCallback$1(()=>{setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)},[storeRef,recoilState])},useSetRecoilState:useSetRecoilState,useSetUnvalidatedAtomValues:function(){const storeRef=useStoreRef$1();return(values,transactionMetadata={})=>{batchUpdates$2(()=>{storeRef.current.addTransactionMetadata(transactionMetadata),values.forEach((value,key)=>setUnvalidatedRecoilValue$2(storeRef.current,new AbstractRecoilValue$3(key),value))})}},useTransactionObservation_DEPRECATED:function(callback){useTransactionSubscription(useCallback$1(store=>{let previousTree=store.getState().previousTree;const currentTree=store.getState().currentTree;previousTree||(previousTree=store.getState().currentTree);const atomValues=externallyVisibleAtomValuesInState(currentTree),previousAtomValues=externallyVisibleAtomValuesInState(previousTree),atomInfo=Recoil_mapMap(nodes$1,node=>{var _node$persistence_UNS,_node$persistence_UNS2,_node$persistence_UNS3,_node$persistence_UNS4;return{persistence_UNSTABLE:{type:null!==(_node$persistence_UNS=null===(_node$persistence_UNS2=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS2?void 0:_node$persistence_UNS2.type)&&void 0!==_node$persistence_UNS?_node$persistence_UNS:"none",backButton:null!==(_node$persistence_UNS3=null===(_node$persistence_UNS4=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS4?void 0:_node$persistence_UNS4.backButton)&&void 0!==_node$persistence_UNS3&&_node$persistence_UNS3}}}),modifiedAtoms=Recoil_filterSet(currentTree.dirtyAtoms,k=>atomValues.has(k)||previousAtomValues.has(k));callback({atomValues:atomValues,previousAtomValues:previousAtomValues,atomInfo:atomInfo,modifiedAtoms:modifiedAtoms,transactionMetadata:{...currentTree.transactionMetadata}})},[callback]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};const{peekNodeInfo:peekNodeInfo$2}=Recoil_FunctionalCore,{useStoreRef:useStoreRef$2}=Recoil_RecoilRoot_react;var Recoil_useGetRecoilValueInfo=function(){const storeRef=useStoreRef$2();return({key:key})=>peekNodeInfo$2(storeRef.current,storeRef.current.getState().currentTree,key)};const{RecoilRoot:RecoilRoot$1,useStoreRef:useStoreRef$3}=Recoil_RecoilRoot_react,{useMemo:useMemo$2}=react;var Recoil_useRecoilBridgeAcrossReactRoots=function(){const store=useStoreRef$3().current;return useMemo$2(()=>function({children:children}){return react.createElement(RecoilRoot$1,{store_INTERNAL:store},children)},[store])};var Recoil_isPromise=function(p){return!!p&&"function"==typeof p.then};class Canceled{}const CANCELED=new Canceled,loadableAccessors={getValue(){if("loading"===this.state)throw this.contents.then(({__value:__value})=>__value);if("hasValue"!==this.state)throw this.contents;return this.contents},toPromise(){return"hasValue"===this.state?Promise.resolve(this.contents):"hasError"===this.state?Promise.reject(this.contents):this.contents.then(({__value:__value})=>__value)},valueMaybe(){return"hasValue"===this.state?this.contents:void 0},valueOrThrow(){if("hasValue"!==this.state){throw new Error(`Loadable expected value, but in "${this.state}" state`)}return this.contents},errorMaybe(){return"hasError"===this.state?this.contents:void 0},errorOrThrow(){if("hasError"!==this.state){throw new Error(`Loadable expected error, but in "${this.state}" state`)}return this.contents},promiseMaybe(){return"loading"===this.state?this.contents.then(({__value:__value})=>__value):void 0},promiseOrThrow(){if("loading"!==this.state){throw new Error(`Loadable expected promise, but in "${this.state}" state`)}return this.contents.then(({__value:__value})=>__value)},is(other){return other.state===this.state&&other.contents===this.contents},map(map){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const next=map(this.contents);return Recoil_isPromise(next)?loadableWithPromise(next):loadableWithValue(next)}catch(e){return Recoil_isPromise(e)?loadableWithPromise(e.next(()=>map(this.contents))):loadableWithError(e)}if("loading"===this.state)return loadableWithPromise(this.contents.then(map).catch(e=>{if(Recoil_isPromise(e))return e.then(()=>map(this.contents));throw e}));throw new Error("Invalid Loadable state")}};function loadableWithValue(value){return Object.freeze({state:"hasValue",contents:value,...loadableAccessors})}function loadableWithError(error){return Object.freeze({state:"hasError",contents:error,...loadableAccessors})}function loadableWithPromise(promise){return Object.freeze({state:"loading",contents:promise,...loadableAccessors})}var Recoil_Loadable={loadableWithValue:loadableWithValue,loadableWithError:loadableWithError,loadableWithPromise:loadableWithPromise,loadableLoading:function(){return loadableWithPromise(new Promise(()=>{}))},loadableAll:function(inputs){return inputs.every(i=>"hasValue"===i.state)?loadableWithValue(inputs.map(i=>i.contents)):inputs.some(i=>"hasError"===i.state)?loadableWithError(Recoil_nullthrows(inputs.find(i=>"hasError"===i.state),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Promise.all(inputs.map(i=>i.contents)).then(value=>({__value:value})))},Canceled:Canceled,CANCELED:CANCELED};var Recoil_stableStringify=function(x,opt={allowFunctions:!1}){return function stringify(x,opt,key){if("string"==typeof x&&!x.includes('"')&&!x.includes("\\"))return`"${x}"`;switch(typeof x){case"undefined":return"";case"boolean":return x?"true":"false";case"number":case"symbol":return String(x);case"string":return JSON.stringify(x);case"function":if(!0!==(null==opt?void 0:opt.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${x.name})__`}if(null===x)return"null";var _JSON$stringify;if("object"!=typeof x)return null!==(_JSON$stringify=JSON.stringify(x))&&void 0!==_JSON$stringify?_JSON$stringify:"";if(Recoil_isPromise(x))return"__PROMISE__";if(Array.isArray(x))return`[${x.map((v,i)=>stringify(v,opt,i.toString()))}]`;if("function"==typeof x.toJSON)return stringify(x.toJSON(key),opt,key);if(x instanceof Map){const obj={};for(const[k,v]of x)obj["string"==typeof k?k:stringify(k,opt)]=v;return stringify(obj,opt,key)}return x instanceof Set?stringify(Array.from(x).sort((a,b)=>stringify(a,opt).localeCompare(stringify(b,opt))),opt,key):void 0!==Symbol&&null!=x[Symbol.iterator]&&"function"==typeof x[Symbol.iterator]?stringify(Array.from(x),opt,key):`{${Object.keys(x).filter(key=>void 0!==x[key]).sort().map(key=>`${stringify(key,opt)}:${stringify(x[key],opt,key)}`).join(",")}}`}(x,opt)};const findLeaf=(root,getNodeValue,handlers)=>{var _handlers$onNodeVisit;if(null==root)return;if(null==handlers||null===(_handlers$onNodeVisit=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit||_handlers$onNodeVisit.call(handlers,root),"leaf"===root.type)return root;const nodeValue=getNodeValue(root.nodeKey);return findLeaf(root.branches.get(nodeValue),getNodeValue,handlers)},addLeaf=(root,route,parent,value,branchKey,handlers)=>{var _handlers$onNodeVisit2;let node;if(null==root)if(0===route.length)node={type:"leaf",value:value,parent:parent,branchKey:branchKey};else{const[path,...rest]=route,[nodeKey,nodeValue]=path;node={type:"branch",nodeKey:nodeKey,parent:parent,branches:new Map,branchKey:branchKey},node.branches.set(nodeValue,addLeaf(null,rest,node,value,nodeValue,handlers))}else if(node=root,route.length){const[path,...rest]=route,[nodeKey,nodeValue]=path;("branch"!==root.type||root.nodeKey!==nodeKey)&&Recoil_invariant(!1),root.branches.set(nodeValue,addLeaf(root.branches.get(nodeValue),rest,root,value,nodeValue,handlers))}return null==handlers||null===(_handlers$onNodeVisit2=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit2||_handlers$onNodeVisit2.call(handlers,node),node},pruneNodeFromTree=(root,node,parent)=>parent?(parent.branches.delete(node.branchKey),pruneUpstreamBranches(root,parent,parent.parent)):root===node,pruneUpstreamBranches=(root,branchNode,parent)=>parent?(0===branchNode.branches.size&&parent.branches.delete(branchNode.branchKey),pruneUpstreamBranches(root,parent,parent.parent)):root===branchNode,countDownstreamLeaves=node=>"leaf"===node.type?1:Array.from(node.branches.values()).reduce((sum,currNode)=>sum+countDownstreamLeaves(currNode),0);var Recoil_TreeCache_1=class{constructor(options){var _options$onHit,_options$onSet,_options$mapNodeValue;_defineProperty(this,"_numLeafs",void 0),_defineProperty(this,"_root",void 0),_defineProperty(this,"_onHit",void 0),_defineProperty(this,"_onSet",void 0),_defineProperty(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(_options$onHit=null==options?void 0:options.onHit)&&void 0!==_options$onHit?_options$onHit:()=>{},this._onSet=null!==(_options$onSet=null==options?void 0:options.onSet)&&void 0!==_options$onSet?_options$onSet:()=>{},this._mapNodeValue=null!==(_options$mapNodeValue=null==options?void 0:options.mapNodeValue)&&void 0!==_options$mapNodeValue?_options$mapNodeValue:val=>val}size(){return this._numLeafs}root(){return this._root}get(getNodeValue,handlers){var _this$getLeafNode;return null===(_this$getLeafNode=this.getLeafNode(getNodeValue,handlers))||void 0===_this$getLeafNode?void 0:_this$getLeafNode.value}getLeafNode(getNodeValue,handlers){return findLeaf(this.root(),nodeKey=>this._mapNodeValue(getNodeValue(nodeKey)),{onNodeVisit:node=>{null==handlers||handlers.onNodeVisit(node),"leaf"===node.type&&this._onHit(node)}})}set(route,value,handlers){let leafNode;const newRoot=addLeaf(this.root(),route.map(([nodeKey,nodeValue])=>[nodeKey,this._mapNodeValue(nodeValue)]),null,value,null,{onNodeVisit:node=>{null==handlers||handlers.onNodeVisit(node),"leaf"===node.type&&(leafNode=node)}});this.root()||(this._root=newRoot),this._numLeafs++,this._onSet(Recoil_nullthrows(leafNode))}delete(node){if(!this.root())return!1;const root=Recoil_nullthrows(this.root());return!!pruneNodeFromTree(root,node,node.parent)&&(node===root||"branch"===root.type&&!root.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=countDownstreamLeaves(node),!0))}clear(){this._numLeafs=0,this._root=null}},Recoil_TreeCache$1=Object.freeze({__proto__:null,TreeCache:Recoil_TreeCache_1});var Recoil_LRUCache_1=class{constructor(options){var _options$mapKey;_defineProperty(this,"_maxSize",void 0),_defineProperty(this,"_size",void 0),_defineProperty(this,"_head",void 0),_defineProperty(this,"_tail",void 0),_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._maxSize=options.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(_options$mapKey=options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(key){return this._map.has(this._keyMapper(key))}get(key){const mappedKey=this._keyMapper(key),node=this._map.get(mappedKey);if(node)return this.set(key,node.value),node.value}set(key,val){const mappedKey=this._keyMapper(key);this._map.get(mappedKey)&&this.delete(key);const head=this.head(),node={key:key,right:head,left:null,value:val};head?head.left=node:this._tail=node,this._map.set(mappedKey,node),this._head=node,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const tail=this.tail();tail&&this.delete(tail.key)}delete(key){const mappedKey=this._keyMapper(key);if(!this._size||!this._map.has(mappedKey))return;const node=Recoil_nullthrows(this._map.get(mappedKey)),right=node.right,left=node.left;right&&(right.left=node.left),left&&(left.right=node.right),node===this.head()&&(this._head=right),node===this.tail()&&(this._tail=left),this._map.delete(mappedKey),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Recoil_LRUCache$1=Object.freeze({__proto__:null,LRUCache:Recoil_LRUCache_1});const{LRUCache:LRUCache$1}=Recoil_LRUCache$1,{TreeCache:TreeCache$1}=Recoil_TreeCache$1;var Recoil_treeCacheLRU=function(maxSize,mapNodeValue=(v=>v)){const lruCache=new LRUCache$1({maxSize:maxSize}),cache=new TreeCache$1({mapNodeValue:mapNodeValue,onHit:node=>{lruCache.set(node,!0)},onSet:node=>{const lruNode=lruCache.tail();lruCache.set(node,!0),lruNode&&cache.size()>maxSize&&cache.delete(lruNode.key)}});return cache};const{TreeCache:TreeCache$2}=Recoil_TreeCache$1,defaultPolicy={equality:"reference",eviction:"none",maxSize:1/0};var Recoil_treeCacheFromPolicy=function({equality:equality=defaultPolicy.equality,eviction:eviction=defaultPolicy.eviction,maxSize:maxSize=defaultPolicy.maxSize}=defaultPolicy){return function(eviction,maxSize,mapNodeValue){switch(eviction){case"none":return new TreeCache$2({mapNodeValue:mapNodeValue});case"lru":return Recoil_treeCacheLRU(Recoil_nullthrows(maxSize),mapNodeValue)}throw new Error("Unrecognized eviction policy "+eviction)}(eviction,maxSize,function(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw new Error("Unrecognized equality policy "+equality)}(equality))};var Recoil_PerformanceTimings={startPerfBlock:function(_id){return()=>null}};const{CANCELED:CANCELED$1,Canceled:Canceled$1,loadableWithError:loadableWithError$1,loadableWithPromise:loadableWithPromise$1,loadableWithValue:loadableWithValue$1}=Recoil_Loadable,{getNodeLoadable:getNodeLoadable$2,peekNodeLoadable:peekNodeLoadable$1,setNodeValue:setNodeValue$3}=Recoil_FunctionalCore,{saveDependencyMapToStore:saveDependencyMapToStore$1}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$3,RecoilValueNotReady:RecoilValueNotReady$2,getConfigDeletionHandler:getConfigDeletionHandler$1,registerNode:registerNode$1}=Recoil_Node,{isRecoilValue:isRecoilValue$2}=Recoil_RecoilValue$1,{AbstractRecoilValue:AbstractRecoilValue$4}=Recoil_RecoilValue$1,{setRecoilValueLoadable:setRecoilValueLoadable$2}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$1}=Recoil_Retention,{startPerfBlock:startPerfBlock$1}=Recoil_PerformanceTimings,dependencyStack=[],waitingStores=new Map,getNewExecutionId=(()=>{let executionId=0;return()=>executionId++})();var Recoil_selector=function(options){const{key:key,get:get,cachePolicy_UNSTABLE:cachePolicy}=options,set=null!=options.set?options.set:void 0,cache=Recoil_treeCacheFromPolicy(null!=cachePolicy?cachePolicy:{equality:"reference",eviction:"none"}),retainedBy=retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE),executionInfoMap=new Map;let liveStoresCount=0;function selectorIsLive(){return!Recoil_gkx_1("recoil_memory_managament_2020")||liveStoresCount>0}function getExecutionInfo(store){return executionInfoMap.has(store)||executionInfoMap.set(store,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),Recoil_nullthrows(executionInfoMap.get(store))}function selectorInit(store){return liveStoresCount++,store.getState().knownSelectors.add(key),()=>{liveStoresCount--,store.getState().knownSelectors.delete(key),executionInfoMap.delete(store)}}function selectorShouldDeleteConfigOnRelease(){return void 0!==getConfigDeletionHandler$1(key)&&!selectorIsLive()}function notifyStoreWhenAsyncSettles(store,loadable,executionId){if("loading"===loadable.state){let stores=waitingStores.get(executionId);null==stores&&waitingStores.set(executionId,stores=new Set),stores.add(store)}}function getCachedNodeLoadable(store,state,key){if(state.atomValues.has(key))return Recoil_nullthrows(state.atomValues.get(key));const loadable=getNodeLoadable$2(store,state,key),isKeyPointingToSelector=store.getState().knownSelectors.has(key);return"loading"!==loadable.state&&isKeyPointingToSelector&&state.atomValues.set(key,loadable),loadable}function wrapPendingDependencyPromise(store,promise,state,existingDeps,executionId){return promise.then(resolvedDep=>{if(!selectorIsLive())return clearExecutionInfo(store,executionId),CANCELED$1;if(resolvedDep instanceof Canceled$1)return CANCELED$1;const{__key:resolvedDepKey,__value:depValue}=null!=resolvedDep?resolvedDep:{};let bypassSelectorDepCacheOnReevaluation=!0;null!=resolvedDepKey&&(state.atomValues.set(resolvedDepKey,loadableWithValue$1(depValue)),bypassSelectorDepCacheOnReevaluation=!1);const[loadable,depValues]=evaluateSelectorGetter(store,state,executionId,bypassSelectorDepCacheOnReevaluation);if(isLatestExecution(store,executionId)&&updateExecutionInfoDepValues(depValues,store,executionId),maybeFreezeLoadableContents(loadable),"loading"!==loadable.state&&(setCache(state,depValuesToDepRoute(depValues),loadable),setDepsInStore(store,state,new Set(depValues.keys()),executionId),setLoadableInStoreToNotifyDeps(store,loadable,executionId)),"hasError"===loadable.state)throw loadable.contents;return"hasValue"===loadable.state?{__value:loadable.contents,__key:key}:loadable.contents}).catch(error=>{if(!selectorIsLive())return clearExecutionInfo(store,executionId),CANCELED$1;const loadable=loadableWithError$1(error);throw setCache(state,depValuesToDepRoute(existingDeps),loadableWithError$1(error)),setDepsInStore(store,state,new Set(existingDeps.keys()),executionId),setLoadableInStoreToNotifyDeps(store,loadable,executionId),error})}function setLoadableInStoreToNotifyDeps(store,loadable,executionId){isLatestExecution(store,executionId)&&(setExecutionInfo(loadable,store),function(newLoadable,executionId){const stores=waitingStores.get(executionId);if(void 0!==stores){for(const store of stores)setRecoilValueLoadable$2(store,new AbstractRecoilValue$4(key),newLoadable);waitingStores.delete(executionId)}}(loadable,executionId))}function setDepsInStore(store,state,deps,executionId){var _store$getState,_store$getState$curre,_store$getState2,_store$getState2$next,_store$getState$nextT,_store$getState3,_store$getState3$next;(isLatestExecution(store,executionId)||state.version===(null===(_store$getState=store.getState())||void 0===_store$getState||null===(_store$getState$curre=_store$getState.currentTree)||void 0===_store$getState$curre?void 0:_store$getState$curre.version)||state.version===(null===(_store$getState2=store.getState())||void 0===_store$getState2||null===(_store$getState2$next=_store$getState2.nextTree)||void 0===_store$getState2$next?void 0:_store$getState2$next.version))&&saveDependencyMapToStore$1(new Map([[key,deps]]),store,null!==(_store$getState$nextT=null===(_store$getState3=store.getState())||void 0===_store$getState3||null===(_store$getState3$next=_store$getState3.nextTree)||void 0===_store$getState3$next?void 0:_store$getState3$next.version)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree.version)}function evaluateSelectorGetter(store,state,executionId,bypassSelectorDepCache=!1){const endPerfBlock=startPerfBlock$1(key);let result,loadable,resultIsError=!1;const depValues=new Map,deps=new Set;function getRecoilValue(recoilValue){const{key:depKey}=recoilValue;!function(store,state,deps,newDepKey,executionId){deps.add(newDepKey),setDepsInStore(store,state,deps,executionId)}(store,state,deps,depKey,executionId);const depLoadable=bypassSelectorDepCache?getNodeLoadable$2(store,state,depKey):getCachedNodeLoadable(store,state,depKey);if(depValues.set(depKey,depLoadable),"hasValue"===depLoadable.state)return depLoadable.contents;throw depLoadable.contents}setDepsInStore(store,state,deps,executionId);try{result=get({get:getRecoilValue}),result=isRecoilValue$2(result)?getRecoilValue(result):result,Recoil_isPromise(result)?result=function(store,promise,state,depValues,executionId){return promise.then(value=>{if(!selectorIsLive())return clearExecutionInfo(store,executionId),CANCELED$1;const loadable=loadableWithValue$1(value);return setCache(state,depValuesToDepRoute(depValues),loadable),setDepsInStore(store,state,new Set(depValues.keys()),executionId),setLoadableInStoreToNotifyDeps(store,loadable,executionId),{__value:value,__key:key}}).catch(errorOrPromise=>{if(!selectorIsLive())return clearExecutionInfo(store,executionId),CANCELED$1;if(isLatestExecution(store,executionId)&&updateExecutionInfoDepValues(depValues,store,executionId),Recoil_isPromise(errorOrPromise))return wrapPendingDependencyPromise(store,errorOrPromise,state,depValues,executionId);const loadable=loadableWithError$1(errorOrPromise);throw setCache(state,depValuesToDepRoute(depValues),loadable),setDepsInStore(store,state,new Set(depValues.keys()),executionId),setLoadableInStoreToNotifyDeps(store,loadable,executionId),errorOrPromise})}(store,result,state,depValues,executionId).finally(endPerfBlock):endPerfBlock()}catch(errorOrDepPromise){result=errorOrDepPromise,Recoil_isPromise(result)?result=wrapPendingDependencyPromise(store,result,state,depValues,executionId).finally(endPerfBlock):(resultIsError=!0,endPerfBlock())}return loadable=resultIsError?loadableWithError$1(result):Recoil_isPromise(result)?loadableWithPromise$1(result):loadableWithValue$1(result),maybeFreezeLoadableContents(loadable),[loadable,depValues]}function depValuesToDepRoute(depValues){return Array.from(depValues.entries()).map(([key,valLoadable])=>[key,valLoadable.contents])}function getValFromRunningNewExecutionAndUpdatedDeps(store,state){const newExecutionId=getNewExecutionId(),[loadable,newDepValues]=evaluateSelectorGetter(store,state,newExecutionId);return setExecutionInfo(loadable,store,newDepValues,newExecutionId,state),function(state,depRoute,loadable){"loading"!==loadable.state&&setCache(state,depRoute,loadable)}(state,depValuesToDepRoute(newDepValues),loadable),notifyStoreWhenAsyncSettles(store,loadable,newExecutionId),loadable}function getSelectorValAndUpdatedDeps(store,state){const cachedVal=function(store,state){const depsAfterCacheDone=new Set,executionInfo=getExecutionInfo(store),cachedVal=cache.get(nodeKey=>{"string"!=typeof nodeKey&&Recoil_invariant(!1);return getCachedNodeLoadable(store,state,nodeKey).contents},{onNodeVisit:node=>{"branch"===node.type&&node.nodeKey!==key&&"string"==typeof node.nodeKey&&depsAfterCacheDone.add(node.nodeKey)}});return cachedVal&&setDepsInStore(store,state,depsAfterCacheDone,executionInfo.latestExecutionId),cachedVal}(store,state);if(null!=cachedVal)return setExecutionInfo(cachedVal,store),cachedVal;const inProgressExecutionInfo=function(store,state){var _Array$from$find;const[,executionInfo]=null!==(_Array$from$find=Array.from(executionInfoMap.entries()).find(([,executionInfo])=>null!=executionInfo.latestLoadable&&null!=executionInfo.latestExecutionId&&!function(store,state){var _executionInfo$depVal,_mapOfCheckedVersions;const executionInfo=getExecutionInfo(store),oldDepValues=null!==(_executionInfo$depVal=executionInfo.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==_executionInfo$depVal?_executionInfo$depVal:new Map,cachedDepValuesCheckedForThisVersion=Array((null!==(_mapOfCheckedVersions=mapOfCheckedVersions.get(state.version))&&void 0!==_mapOfCheckedVersions?_mapOfCheckedVersions:new Map).entries()),isCachedVersionSame=mapOfCheckedVersions.has(state.version)&&cachedDepValuesCheckedForThisVersion.length===oldDepValues.size&&cachedDepValuesCheckedForThisVersion.every(([nodeKey,nodeVal])=>oldDepValues.get(nodeKey)===nodeVal);if(null==oldDepValues||state.version===executionInfo.stateVersion||isCachedVersionSame)return!1;return mapOfCheckedVersions.set(state.version,new Map(oldDepValues)),Array.from(oldDepValues).some(([nodeKey,oldVal])=>{const loadable=getCachedNodeLoadable(store,state,nodeKey);return loadable.contents!==oldVal.contents&&!("loading"===oldVal.state&&"loading"!==loadable.state)})}(store,state)))&&void 0!==_Array$from$find?_Array$from$find:[];return executionInfo}(store,state);if(inProgressExecutionInfo){const executionInfo=inProgressExecutionInfo;return notifyStoreWhenAsyncSettles(store,Recoil_nullthrows(executionInfo.latestLoadable),Recoil_nullthrows(executionInfo.latestExecutionId)),Recoil_nullthrows(executionInfo.latestLoadable)}return getValFromRunningNewExecutionAndUpdatedDeps(store,state)}const mapOfCheckedVersions=new Map;function setExecutionInfo(loadable,store,depValues,newExecutionId,state){const executionInfo=getExecutionInfo(store);"loading"===loadable.state?(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues,executionInfo.latestExecutionId=newExecutionId,executionInfo.latestLoadable=loadable,executionInfo.stateVersion=null==state?void 0:state.version):(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=null,executionInfo.latestExecutionId=null,executionInfo.latestLoadable=null,executionInfo.stateVersion=null)}function updateExecutionInfoDepValues(depValues,store,executionId){const executionInfo=getExecutionInfo(store);isLatestExecution(store,executionId)&&(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues)}function clearExecutionInfo(store,executionId){isLatestExecution(store,executionId)&&executionInfoMap.delete(store)}function isLatestExecution(store,executionId){return executionId===getExecutionInfo(store).latestExecutionId}function maybeFreezeLoadableContents(loadable){"loading"!==loadable.state&&loadable.contents}function setCache(state,cacheRoute,loadable){state.atomValues.set(key,loadable),cache.set(cacheRoute,loadable)}function selectorPeek(store,state){return cache.get(nodeKey=>{"string"!=typeof nodeKey&&Recoil_invariant(!1);const peek=peekNodeLoadable$1(store,state,nodeKey);return null==peek?void 0:peek.contents})}function selectorGet(store,state){return function(fn){if(dependencyStack.includes(key)){const message="Recoil selector has circular dependencies: "+dependencyStack.slice(dependencyStack.indexOf(key)).join(" → ");return loadableWithError$1(new Error(message))}dependencyStack.push(key);try{return fn()}finally{dependencyStack.pop()}}(()=>getSelectorValAndUpdatedDeps(store,state))}function invalidateSelector(state){state.atomValues.delete(key)}if(null!=set){return registerNode$1({key:key,peek:selectorPeek,get:selectorGet,set:function(store,state,newValue){let syncSelectorSetFinished=!1;const writes=new Map;function getRecoilValue({key:key}){if(syncSelectorSetFinished)throw new Error("Recoil: Async selector sets are not currently supported.");const loadable=getCachedNodeLoadable(store,state,key);if("hasValue"===loadable.state)return loadable.contents;throw"loading"===loadable.state?new RecoilValueNotReady$2(key):loadable.contents}function setRecoilState(recoilState,valueOrUpdater){if(syncSelectorSetFinished)throw new Error("Recoil: Async selector sets are not currently supported.");const newValue="function"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater;setNodeValue$3(store,state,recoilState.key,newValue).forEach((v,k)=>writes.set(k,v))}const ret=set({set:setRecoilState,get:getRecoilValue,reset:function(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$3)}},newValue);if(void 0!==ret)throw Recoil_isPromise(ret)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return syncSelectorSetFinished=!0,writes},init:selectorInit,invalidate:invalidateSelector,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:retainedBy})}return registerNode$1({key:key,peek:selectorPeek,get:selectorGet,init:selectorInit,invalidate:invalidateSelector,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:retainedBy})};const{loadableWithError:loadableWithError$2,loadableWithPromise:loadableWithPromise$2,loadableWithValue:loadableWithValue$2}=Recoil_Loadable,{DEFAULT_VALUE:DEFAULT_VALUE$4,DefaultValue:DefaultValue$2,getConfigDeletionHandler:getConfigDeletionHandler$2,registerNode:registerNode$2,setConfigDeletionHandler:setConfigDeletionHandler$1}=Recoil_Node,{isRecoilValue:isRecoilValue$3}=Recoil_RecoilValue$1,{markRecoilValueModified:markRecoilValueModified$1,setRecoilValue:setRecoilValue$3,setRecoilValueLoadable:setRecoilValueLoadable$3}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$2}=Recoil_Retention;function baseAtom(options){const{key:key,persistence_UNSTABLE:persistence}=options,retainedBy=retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);let liveStoresCount=0,defaultLoadable=Recoil_isPromise(options.default)?loadableWithPromise$2(options.default.then(value=>{defaultLoadable=loadableWithValue$2(value);return{__key:key,__value:value}}).catch(error=>{throw defaultLoadable=loadableWithError$2(error),error})):loadableWithValue$2(options.default),cachedAnswerForUnvalidatedValue=void 0;const cleanupEffectsByStore=new Map;const node=registerNode$2({key:key,peek:function(_store,state){var _ref,_state$atomValues$get3,_cachedAnswerForUnval;return null!==(_ref=null!==(_state$atomValues$get3=state.atomValues.get(key))&&void 0!==_state$atomValues$get3?_state$atomValues$get3:null===(_cachedAnswerForUnval=cachedAnswerForUnvalidatedValue)||void 0===_cachedAnswerForUnval?void 0:_cachedAnswerForUnval[1])&&void 0!==_ref?_ref:defaultLoadable},get:function(_store,state){if(state.atomValues.has(key))return Recoil_nullthrows(state.atomValues.get(key));if(state.nonvalidatedAtoms.has(key)){if(null!=cachedAnswerForUnvalidatedValue)return cachedAnswerForUnvalidatedValue;if(null==persistence)return defaultLoadable;const nonvalidatedValue=state.nonvalidatedAtoms.get(key),validatorResult=persistence.validator(nonvalidatedValue,DEFAULT_VALUE$4),validatedValueLoadable=validatorResult instanceof DefaultValue$2?defaultLoadable:loadableWithValue$2(validatorResult);return cachedAnswerForUnvalidatedValue=validatedValueLoadable,cachedAnswerForUnvalidatedValue}return defaultLoadable},set:function(_store,state,newValue){if(state.atomValues.has(key)){const existing=Recoil_nullthrows(state.atomValues.get(key));if("hasValue"===existing.state&&newValue===existing.contents)return new Map}else if(!state.nonvalidatedAtoms.has(key)&&newValue instanceof DefaultValue$2)return new Map;return cachedAnswerForUnvalidatedValue=void 0,(new Map).set(key,loadableWithValue$2(newValue))},init:function(store,initState,trigger){liveStoresCount++;const alreadyKnown=store.getState().knownAtoms.has(key);if(store.getState().knownAtoms.add(key),"loading"===defaultLoadable.state){const notifyDefaultSubscribers=()=>{var _store$getState$nextT3;(null!==(_store$getState$nextT3=store.getState().nextTree)&&void 0!==_store$getState$nextT3?_store$getState$nextT3:store.getState().currentTree).atomValues.has(key)||markRecoilValueModified$1(store,node)};defaultLoadable.contents.then(notifyDefaultSubscribers).catch(notifyDefaultSubscribers)}let initValue=DEFAULT_VALUE$4,pendingSetSelf=null;if(null!=options.effects_UNSTABLE&&!alreadyKnown){let duringInit=!0;const setSelf=effect=>valueOrUpdater=>{if(duringInit){const currentValue=initValue instanceof DefaultValue$2||Recoil_isPromise(initValue)?"hasValue"===defaultLoadable.state?defaultLoadable.contents:DEFAULT_VALUE$4:initValue;initValue="function"==typeof valueOrUpdater?valueOrUpdater(currentValue):valueOrUpdater}else{if(Recoil_isPromise(valueOrUpdater))throw new Error("Setting atoms to async values is not implemented.");"function"!=typeof valueOrUpdater&&(pendingSetSelf={effect:effect,value:valueOrUpdater}),setRecoilValue$3(store,node,"function"==typeof valueOrUpdater?currentValue=>{const newValue=valueOrUpdater(currentValue);return pendingSetSelf={effect:effect,value:newValue},newValue}:valueOrUpdater)}},resetSelf=effect=>()=>setSelf(effect)(DEFAULT_VALUE$4),onSet=effect=>handler=>{store.subscribeToTransactions(currentStore=>{var _pendingSetSelf3;let{currentTree:currentTree,previousTree:previousTree}=currentStore.getState();previousTree||(previousTree=currentTree);const newLoadable=currentTree.atomValues.get(key);if(null==newLoadable||"hasValue"===newLoadable.state){var _previousTree$atomVal,_pendingSetSelf,_pendingSetSelf2;const newValue=null!=newLoadable?newLoadable.contents:DEFAULT_VALUE$4,oldLoadable=null!==(_previousTree$atomVal=previousTree.atomValues.get(key))&&void 0!==_previousTree$atomVal?_previousTree$atomVal:defaultLoadable,oldValue="hasValue"===oldLoadable.state?oldLoadable.contents:DEFAULT_VALUE$4;(null===(_pendingSetSelf=pendingSetSelf)||void 0===_pendingSetSelf?void 0:_pendingSetSelf.effect)===effect&&(null===(_pendingSetSelf2=pendingSetSelf)||void 0===_pendingSetSelf2?void 0:_pendingSetSelf2.value)===newValue||handler(newValue,oldValue)}(null===(_pendingSetSelf3=pendingSetSelf)||void 0===_pendingSetSelf3?void 0:_pendingSetSelf3.effect)===effect&&(pendingSetSelf=null)},key)};for(const effect of null!==(_options$effects_UNST=options.effects_UNSTABLE)&&void 0!==_options$effects_UNST?_options$effects_UNST:[]){var _options$effects_UNST;const cleanup=effect({node:node,trigger:trigger,setSelf:setSelf(effect),resetSelf:resetSelf(effect),onSet:onSet(effect)});null!=cleanup&&cleanupEffectsByStore.set(store,cleanup)}duringInit=!1}if(!(initValue instanceof DefaultValue$2)){var _store$getState$nextT4;const initLoadable=Recoil_isPromise(initValue)?loadableWithPromise$2(function(store,promise){const wrappedPromise=promise.then(value=>{var _store$getState$nextT,_state$atomValues$get;return(null===(_state$atomValues$get=(null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get?void 0:_state$atomValues$get.contents)===wrappedPromise&&setRecoilValue$3(store,node,value),{__key:key,__value:value}}).catch(error=>{var _store$getState$nextT2,_state$atomValues$get2;throw(null===(_state$atomValues$get2=(null!==(_store$getState$nextT2=store.getState().nextTree)&&void 0!==_store$getState$nextT2?_store$getState$nextT2:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get2?void 0:_state$atomValues$get2.contents)===wrappedPromise&&setRecoilValueLoadable$3(store,node,loadableWithError$2(error)),error});return wrappedPromise}(store,initValue)):loadableWithValue$2(initValue);initState.atomValues.set(key,initLoadable),null===(_store$getState$nextT4=store.getState().nextTree)||void 0===_store$getState$nextT4||_store$getState$nextT4.atomValues.set(key,initLoadable)}return()=>{var _cleanupEffectsByStor;liveStoresCount--,null===(_cleanupEffectsByStor=cleanupEffectsByStore.get(store))||void 0===_cleanupEffectsByStor||_cleanupEffectsByStor(),cleanupEffectsByStore.delete(store),store.getState().knownAtoms.delete(key)}},invalidate:function(){cachedAnswerForUnvalidatedValue=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==getConfigDeletionHandler$2(key)&&liveStoresCount<=0},dangerouslyAllowMutability:options.dangerouslyAllowMutability,persistence_UNSTABLE:options.persistence_UNSTABLE?{type:options.persistence_UNSTABLE.type,backButton:options.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:retainedBy});return node}function atom(options){const{default:optionsDefault,...restOptions}=options;return isRecoilValue$3(optionsDefault)?function(options){const base=atom({...options,default:DEFAULT_VALUE$4,persistence_UNSTABLE:void 0===options.persistence_UNSTABLE?void 0:{...options.persistence_UNSTABLE,validator:storedValue=>storedValue instanceof DefaultValue$2?storedValue:Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue,DEFAULT_VALUE$4)},effects_UNSTABLE:options.effects_UNSTABLE}),sel=Recoil_selector({key:options.key+"__withFallback",get:({get:get})=>{const baseValue=get(base);return baseValue instanceof DefaultValue$2?options.default:baseValue},set:({set:set},newValue)=>set(base,newValue),dangerouslyAllowMutability:options.dangerouslyAllowMutability});return setConfigDeletionHandler$1(sel.key,getConfigDeletionHandler$2(options.key)),sel}({...restOptions,default:optionsDefault}):baseAtom({...restOptions,default:optionsDefault})}var Recoil_atom=atom;var Recoil_MapCache_1=class{constructor(options){var _options$mapKey;_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(_options$mapKey=null==options?void 0:options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}size(){return this._map.size}has(key){return this._map.has(this._keyMapper(key))}get(key){return this._map.get(this._keyMapper(key))}set(key,val){this._map.set(this._keyMapper(key),val)}delete(key){this._map.delete(this._keyMapper(key))}clear(){this._map.clear()}},Recoil_MapCache$1=Object.freeze({__proto__:null,MapCache:Recoil_MapCache_1});const{LRUCache:LRUCache$2}=Recoil_LRUCache$1,{MapCache:MapCache$1}=Recoil_MapCache$1,defaultPolicy$1={equality:"reference",eviction:"none",maxSize:1/0};var Recoil_cacheFromPolicy=function({equality:equality=defaultPolicy$1.equality,eviction:eviction=defaultPolicy$1.eviction,maxSize:maxSize=defaultPolicy$1.maxSize}=defaultPolicy$1){return function(eviction,maxSize,mapKey){switch(eviction){case"none":return new MapCache$1({mapKey:mapKey});case"lru":return new LRUCache$2({mapKey:mapKey,maxSize:Recoil_nullthrows(maxSize)})}throw new Error("Unrecognized eviction policy "+eviction)}(eviction,maxSize,function(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw new Error("Unrecognized equality policy "+equality)}(equality))};const{setConfigDeletionHandler:setConfigDeletionHandler$2}=Recoil_Node;let nextIndex=0;var Recoil_selectorFamily=function(options){var _options$cachePolicyF;const selectorCache=Recoil_cacheFromPolicy(null!==(_options$cachePolicyF=options.cachePolicyForParams_UNSTABLE)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:{equality:"value",eviction:"none"});return params=>{var _stableStringify;const cachedSelector=selectorCache.get(params);if(null!=cachedSelector)return cachedSelector;const myKey=`${options.key}__selectorFamily/${null!==(_stableStringify=Recoil_stableStringify(params,{allowFunctions:!0}))&&void 0!==_stableStringify?_stableStringify:"void"}/${nextIndex++}`,myGet=callbacks=>options.get(params)(callbacks),myCachePolicy=options.cachePolicy_UNSTABLE,retainedBy="function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE;let newSelector;if(null!=options.set){const set=options.set;newSelector=Recoil_selector({key:myKey,get:myGet,set:(callbacks,newValue)=>set(params)(callbacks,newValue),cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy})}else newSelector=Recoil_selector({key:myKey,get:myGet,cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy});return selectorCache.set(params,newSelector),setConfigDeletionHandler$2(newSelector.key,()=>{selectorCache.delete(params)}),newSelector}};const{DEFAULT_VALUE:DEFAULT_VALUE$5,DefaultValue:DefaultValue$3,setConfigDeletionHandler:setConfigDeletionHandler$3}=Recoil_Node;var Recoil_atomFamily=function(options){var _options$cachePolicyF;const atomCache=Recoil_cacheFromPolicy(null!==(_options$cachePolicyF=options.cachePolicyForParams_UNSTABLE)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:{equality:"value",eviction:"none"}),legacyAtomOptions={key:options.key,default:DEFAULT_VALUE$5,persistence_UNSTABLE:options.persistence_UNSTABLE};let legacyAtom;legacyAtom=Recoil_atom(legacyAtomOptions);const atomFamilyDefault=Recoil_selectorFamily({key:options.key+"__atomFamily/Default",get:param=>({get:get})=>{const legacyValue=get("function"==typeof legacyAtom?legacyAtom(param):legacyAtom);return legacyValue instanceof DefaultValue$3?"function"==typeof options.default?options.default(param):options.default:legacyValue},dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:options.retainedBy_UNSTABLE});return params=>{var _stableStringify;const cachedAtom=atomCache.get(params);if(null!=cachedAtom)return cachedAtom;const{cachePolicyForParams_UNSTABLE:cachePolicyForParams_UNSTABLE,...atomOptions}=options,newAtom=Recoil_atom({...atomOptions,key:`${options.key}__${null!==(_stableStringify=Recoil_stableStringify(params))&&void 0!==_stableStringify?_stableStringify:"void"}`,default:atomFamilyDefault(params),retainedBy_UNSTABLE:"function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE,effects_UNSTABLE:"function"==typeof options.effects_UNSTABLE?options.effects_UNSTABLE(params):options.effects_UNSTABLE});return atomCache.set(params,newAtom),setConfigDeletionHandler$3(newAtom.key,()=>{atomCache.delete(params)}),newAtom}};const constantSelector=Recoil_selectorFamily({key:"__constant",get:constant=>()=>constant,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Recoil_constSelector=function(constant){return constantSelector(constant)};const throwingSelector=Recoil_selectorFamily({key:"__error",get:message=>()=>{throw new Error(message)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Recoil_errorSelector=function(message){return throwingSelector(message)};var Recoil_readOnlySelector=function(atom){return atom};const{loadableWithError:loadableWithError$3,loadableWithPromise:loadableWithPromise$3,loadableWithValue:loadableWithValue$3}=Recoil_Loadable;function concurrentRequests(getRecoilValue,deps){const results=Array(deps.length).fill(void 0),exceptions=Array(deps.length).fill(void 0);for(const[i,dep]of deps.entries())try{results[i]=getRecoilValue(dep)}catch(e){exceptions[i]=e}return[results,exceptions]}function isError(exp){return null!=exp&&!Recoil_isPromise(exp)}function unwrapDependencies(dependencies){return Array.isArray(dependencies)?dependencies:Object.getOwnPropertyNames(dependencies).map(key=>dependencies[key])}function getValueFromLoadablePromiseResult(result){return null!=result&&"object"==typeof result&&result.hasOwnProperty("__value")?result.__value:result}function wrapResults(dependencies,results){return Array.isArray(dependencies)?results:Object.getOwnPropertyNames(dependencies).reduce((out,key,idx)=>({...out,[key]:results[idx]}),{})}function wrapLoadables(dependencies,results,exceptions){return wrapResults(dependencies,exceptions.map((exception,idx)=>null==exception?loadableWithValue$3(results[idx]):Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception)))}var Recoil_WaitFor={waitForNone:Recoil_selectorFamily({key:"__waitForNone",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return wrapLoadables(dependencies,results,exceptions)}}),waitForAny:Recoil_selectorFamily({key:"__waitForAny",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return exceptions.some(exp=>!Recoil_isPromise(exp))?wrapLoadables(dependencies,results,exceptions):new Promise(resolve=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then(result=>{results[i]=getValueFromLoadablePromiseResult(result),exceptions[i]=void 0,resolve(wrapLoadables(dependencies,results,exceptions))}).catch(error=>{exceptions[i]=error,resolve(wrapLoadables(dependencies,results,exceptions))})})}}),waitForAll:Recoil_selectorFamily({key:"__waitForAll",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.every(exp=>null==exp))return wrapResults(dependencies,results);const error=exceptions.find(isError);if(null!=error)throw error;return Promise.all(exceptions).then(exceptionResults=>{return wrapResults(dependencies,(syncResults=results,asyncResults=exceptionResults,asyncResults.map((result,idx)=>void 0===result?syncResults[idx]:result)).map(getValueFromLoadablePromiseResult));var syncResults,asyncResults})}}),waitForAllSettled:Recoil_selectorFamily({key:"__waitForAllSettled",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return exceptions.every(exp=>!Recoil_isPromise(exp))?wrapLoadables(dependencies,results,exceptions):Promise.all(exceptions.map((exp,i)=>Recoil_isPromise(exp)?exp.then(result=>{results[i]=getValueFromLoadablePromiseResult(result),exceptions[i]=void 0}).catch(error=>{results[i]=void 0,exceptions[i]=error}):null)).then(()=>wrapLoadables(dependencies,results,exceptions))}}),noWait:Recoil_selectorFamily({key:"__noWait",get:dependency=>({get:get})=>{try{return loadableWithValue$3(get(dependency))}catch(exception){return Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception)}}})};const{batchUpdates:batchUpdates$3,setBatcher:setBatcher$1}=Recoil_Batching,{DefaultValue:DefaultValue$4}=Recoil_Node,{RecoilRoot:RecoilRoot$2}=Recoil_RecoilRoot_react,{isRecoilValue:isRecoilValue$4}=Recoil_RecoilValue$1,{retentionZone:retentionZone$1}=Recoil_RetentionZone,{freshSnapshot:freshSnapshot$2}=Recoil_Snapshot$1,{useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilCallback:useRecoilCallback$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useRecoilTransactionObserver:useRecoilTransactionObserver$1,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useResetRecoilState:useResetRecoilState$1,useRetain:useRetain$1,useSetRecoilState:useSetRecoilState$1,useSetUnvalidatedAtomValues:useSetUnvalidatedAtomValues$1,useTransactionObservation_DEPRECATED:useTransactionObservation_DEPRECATED$1}=Recoil_Hooks,{noWait:noWait$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,waitForAny:waitForAny$1,waitForNone:waitForNone$1}=Recoil_WaitFor;var Recoil_index={DefaultValue:DefaultValue$4,RecoilRoot:RecoilRoot$2,useRecoilBridgeAcrossReactRoots_UNSTABLE:Recoil_useRecoilBridgeAcrossReactRoots,atom:Recoil_atom,selector:Recoil_selector,retentionZone:retentionZone$1,atomFamily:Recoil_atomFamily,selectorFamily:Recoil_selectorFamily,constSelector:Recoil_constSelector,errorSelector:Recoil_errorSelector,readOnlySelector:Recoil_readOnlySelector,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useSetRecoilState:useSetRecoilState$1,useResetRecoilState:useResetRecoilState$1,useGetRecoilValueInfo_UNSTABLE:Recoil_useGetRecoilValueInfo,useRetain:useRetain$1,useRecoilCallback:useRecoilCallback$1,useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver_UNSTABLE:useRecoilTransactionObserver$1,useTransactionObservation_UNSTABLE:useTransactionObservation_DEPRECATED$1,useSetUnvalidatedAtomValues_UNSTABLE:useSetUnvalidatedAtomValues$1,noWait:noWait$1,waitForNone:waitForNone$1,waitForAny:waitForAny$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,isRecoilValue:isRecoilValue$4,batchUpdates:batchUpdates$3,setBatcher:setBatcher$1,snapshot_UNSTABLE:freshSnapshot$2},Recoil_index_1=Recoil_index.DefaultValue,Recoil_index_2=Recoil_index.RecoilRoot,Recoil_index_3=Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE,Recoil_index_4=Recoil_index.atom,Recoil_index_5=Recoil_index.selector,Recoil_index_6=Recoil_index.retentionZone,Recoil_index_7=Recoil_index.atomFamily,Recoil_index_8=Recoil_index.selectorFamily,Recoil_index_9=Recoil_index.constSelector,Recoil_index_10=Recoil_index.errorSelector,Recoil_index_11=Recoil_index.readOnlySelector,Recoil_index_12=Recoil_index.useRecoilValue,Recoil_index_13=Recoil_index.useRecoilValueLoadable,Recoil_index_14=Recoil_index.useRecoilState,Recoil_index_15=Recoil_index.useRecoilStateLoadable,Recoil_index_16=Recoil_index.useSetRecoilState,Recoil_index_17=Recoil_index.useResetRecoilState,Recoil_index_18=Recoil_index.useGetRecoilValueInfo_UNSTABLE,Recoil_index_19=Recoil_index.useRetain,Recoil_index_20=Recoil_index.useRecoilCallback,Recoil_index_21=Recoil_index.useGotoRecoilSnapshot,Recoil_index_22=Recoil_index.useRecoilSnapshot,Recoil_index_23=Recoil_index.useRecoilTransactionObserver_UNSTABLE,Recoil_index_24=Recoil_index.useTransactionObservation_UNSTABLE,Recoil_index_25=Recoil_index.useSetUnvalidatedAtomValues_UNSTABLE,Recoil_index_26=Recoil_index.noWait,Recoil_index_27=Recoil_index.waitForNone,Recoil_index_28=Recoil_index.waitForAny,Recoil_index_29=Recoil_index.waitForAll,Recoil_index_30=Recoil_index.waitForAllSettled,Recoil_index_31=Recoil_index.isRecoilValue,Recoil_index_32=Recoil_index.batchUpdates,Recoil_index_33=Recoil_index.setBatcher,Recoil_index_34=Recoil_index.snapshot_UNSTABLE;export default Recoil_index;export{Recoil_index_1 as DefaultValue,Recoil_index_2 as RecoilRoot,Recoil_index_4 as atom,Recoil_index_7 as atomFamily,Recoil_index_32 as batchUpdates,Recoil_index_9 as constSelector,Recoil_index_10 as errorSelector,Recoil_index_31 as isRecoilValue,Recoil_index_26 as noWait,Recoil_index_11 as readOnlySelector,Recoil_index_6 as retentionZone,Recoil_index_5 as selector,Recoil_index_8 as selectorFamily,Recoil_index_33 as setBatcher,Recoil_index_34 as snapshot_UNSTABLE,Recoil_index_18 as useGetRecoilValueInfo_UNSTABLE,Recoil_index_21 as useGotoRecoilSnapshot,Recoil_index_3 as useRecoilBridgeAcrossReactRoots_UNSTABLE,Recoil_index_20 as useRecoilCallback,Recoil_index_22 as useRecoilSnapshot,Recoil_index_14 as useRecoilState,Recoil_index_15 as useRecoilStateLoadable,Recoil_index_23 as useRecoilTransactionObserver_UNSTABLE,Recoil_index_12 as useRecoilValue,Recoil_index_13 as useRecoilValueLoadable,Recoil_index_17 as useResetRecoilState,Recoil_index_19 as useRetain,Recoil_index_16 as useSetRecoilState,Recoil_index_25 as useSetUnvalidatedAtomValues_UNSTABLE,Recoil_index_24 as useTransactionObservation_UNSTABLE,Recoil_index_29 as waitForAll,Recoil_index_30 as waitForAllSettled,Recoil_index_28 as waitForAny,Recoil_index_27 as waitForNone};
