{"ast":null,"code":"import { isTransaction as r } from \"@onflow/interaction\";\nimport { encodeTransactionPayload as e, encodeTransactionEnvelope as t } from \"@onflow/encode\";\nimport { sansPrefix as n } from \"@onflow/util-address\";\n\nfunction o() {\n  return (o = Object.assign || function (r) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n\n      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);\n    }\n\n    return r;\n  }).apply(this, arguments);\n}\n\nfunction a(r, e) {\n  (null == e || e > r.length) && (e = r.length);\n\n  for (var t = 0, n = new Array(e); t < e; t++) n[t] = r[t];\n\n  return n;\n}\n\nfunction i(r) {\n  return {\n    script: r.message.cadence,\n    refBlock: r.message.refBlock || null,\n    gasLimit: r.message.computeLimit,\n    arguments: r.message.arguments.map(function (e) {\n      return r.arguments[e].asArgument;\n    }),\n    proposalKey: {\n      address: n(r.accounts[r.proposer].addr),\n      keyId: r.accounts[r.proposer].keyId,\n      sequenceNum: r.accounts[r.proposer].sequenceNum\n    },\n    payer: n(r.accounts[r.payer].addr),\n    authorizers: r.authorizations.map(function (e) {\n      return n(r.accounts[e].addr);\n    }).reduce(function (r, e) {\n      return r.find(function (r) {\n        return r === e;\n      }) ? r : [].concat(r, [e]);\n    }, [])\n  };\n}\n\nvar s = function (n) {\n  try {\n    if (!r(n)) return Promise.resolve(n);\n\n    var a = function (r) {\n      var e = new Set(r.authorizations);\n      e.add(r.proposer), e.delete(r.payer), e = Array.from(e);\n      var t = new Set([r.payer]);\n      return {\n        insideSigners: e,\n        outsideSigners: t = Array.from(t)\n      };\n    }(n),\n        s = a.outsideSigners;\n\n    return Promise.resolve(u(n, a.insideSigners, e(i(n)))).then(function (r) {\n      var e = c(n, r);\n      return Promise.resolve(u(n, s, t(o({}, i(n), {\n        payloadSigs: e\n      })))).then(function (r) {\n        return c(n, r), n;\n      });\n    });\n  } catch (r) {\n    return Promise.reject(r);\n  }\n},\n    u = function (r, e, t) {\n  void 0 === e && (e = []);\n\n  try {\n    return Promise.all(e.map(function (e) {\n      try {\n        return Promise.resolve(r.accounts[e].signingFunction({\n          message: t,\n          addr: n(r.accounts[e].addr),\n          keyId: r.accounts[e].keyId,\n          roles: r.accounts[e].role,\n          interaction: r\n        })).then(function (t) {\n          if (t.cid = e, n(r.accounts[e].addr) !== n(t.addr)) throw new Error(e + \" — mismatching address in composite signature\");\n          if (r.accounts[e].keyId !== t.keyId) throw new Error(e + \" — mismatching keyId in composite signature\");\n          return t.sig = t.signature, t.address = n(t.addr), t;\n        });\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }));\n  } catch (r) {\n    return Promise.reject(r);\n  }\n};\n\nfunction c(r, e) {\n  for (var t, n = function (r, e) {\n    var t;\n\n    if (\"undefined\" == typeof Symbol || null == r[Symbol.iterator]) {\n      if (Array.isArray(r) || (t = function (r, e) {\n        if (r) {\n          if (\"string\" == typeof r) return a(r, void 0);\n          var t = Object.prototype.toString.call(r).slice(8, -1);\n          return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? a(r, void 0) : void 0;\n        }\n      }(r))) {\n        t && (r = t);\n        var n = 0;\n        return function () {\n          return n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[n++]\n          };\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    return (t = r[Symbol.iterator]()).next.bind(t);\n  }(e); !(t = n()).done;) {\n    var o = t.value;\n    r.accounts[o.cid].signature = o.signature;\n  }\n\n  return e;\n}\n\nexport { s as resolveSignatures };","map":{"version":3,"sources":["../src/index.js"],"names":["prepForEncoding","ix","script","message","cadence","refBlock","gasLimit","computeLimit","arguments","map","cid","asArgument","proposalKey","address","sansPrefix","accounts","proposer","addr","keyId","sequenceNum","payer","authorizers","authorizations","reduce","prev","current","find","item","fetchSignatures","signers","Promise","all","compSig","signingFunction","roles","role","interaction","Error","sig","signature","insideSigners","Set","add","Array","from","outsideSigners","mutateAccountsWithSignatures","compSigs","resolveSignatures","isTransaction","collateSigners","insideSignatures","encodeInsideMessage","encodeOutsideMessage","payloadSigs"],"mappings":"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","sourcesContent":["import {isTransaction} from \"@onflow/interaction\"\nimport {\n  encodeTransactionPayload as encodeInsideMessage,\n  encodeTransactionEnvelope as encodeOutsideMessage,\n} from \"@onflow/encode\"\nimport {sansPrefix} from \"@onflow/util-address\"\n\nfunction prepForEncoding(ix) {\n  return {\n    script: ix.message.cadence,\n    refBlock: ix.message.refBlock || null,\n    gasLimit: ix.message.computeLimit,\n    arguments: ix.message.arguments.map(cid => ix.arguments[cid].asArgument),\n    proposalKey: {\n      address: sansPrefix(ix.accounts[ix.proposer].addr),\n      keyId: ix.accounts[ix.proposer].keyId,\n      sequenceNum: ix.accounts[ix.proposer].sequenceNum,\n    },\n    payer: sansPrefix(ix.accounts[ix.payer].addr),\n    authorizers: ix.authorizations\n      .map(cid => sansPrefix(ix.accounts[cid].addr))\n      .reduce((prev, current) => {\n        return prev.find(item => item === current)\n          ? prev\n          : [...prev, current]\n      }, []),\n  }\n}\n\nasync function fetchSignatures(ix, signers = [], message) {\n  return Promise.all(\n    signers.map(async cid => {\n      const compSig = await ix.accounts[cid].signingFunction({\n        message,\n        addr: sansPrefix(ix.accounts[cid].addr),\n        keyId: ix.accounts[cid].keyId,\n        roles: ix.accounts[cid].role, // grr this should be roles,\n        interaction: ix,\n      })\n      compSig.cid = cid\n      if (sansPrefix(ix.accounts[cid].addr) !== sansPrefix(compSig.addr)) {\n        throw new Error(`${cid} — mismatching address in composite signature`)\n      }\n      if (ix.accounts[cid].keyId !== compSig.keyId) {\n        throw new Error(`${cid} — mismatching keyId in composite signature`)\n      }\n      compSig.sig = compSig.signature\n      compSig.address = sansPrefix(compSig.addr)\n      return compSig\n    })\n  )\n}\n\nfunction collateSigners(ix) {\n  // inside signers are: (authorizers + proposer) - payer\n  let insideSigners = new Set(ix.authorizations)\n  insideSigners.add(ix.proposer)\n  insideSigners.delete(ix.payer)\n  insideSigners = Array.from(insideSigners)\n\n  // outside signers are: payer\n  let outsideSigners = new Set([ix.payer])\n  outsideSigners = Array.from(outsideSigners)\n\n  return {insideSigners, outsideSigners}\n}\n\nfunction mutateAccountsWithSignatures(ix, compSigs) {\n  for (let {cid, signature} of compSigs) {\n    ix.accounts[cid].signature = signature\n  }\n  return compSigs\n}\n\nexport async function resolveSignatures(ix) {\n  if (!isTransaction(ix)) return ix\n\n  const {insideSigners, outsideSigners} = collateSigners(ix)\n\n  // Get inside composite signatures for inside payload in parallel\n  const insideSignatures = mutateAccountsWithSignatures(\n    ix,\n    await fetchSignatures(\n      ix,\n      insideSigners,\n      encodeInsideMessage(prepForEncoding(ix))\n    )\n  )\n\n  // Get outside composite signatures for outside payload in parallel\n  const outsideSignatures = mutateAccountsWithSignatures(\n    ix,\n    await fetchSignatures(\n      ix,\n      outsideSigners,\n      encodeOutsideMessage({\n        ...prepForEncoding(ix),\n        payloadSigs: insideSignatures,\n      })\n    )\n  )\n\n  return ix\n}\n\n// TODO — WHAT WE WANT INSTEAD OF WHAT WE HAVE\n//\n// encodeInsideMessage({\n//   cadence: ___,\n//   refBlock: ___,\n//   computeLimit: ___,\n//   proposer: {\n//     addr: ___,\n//     keyId: ___,\n//     sequenceNum: __,\n//   },\n//   payer: ___,\n//   authorizers: [___],\n// })\n//\n// encodeInsideMessage({\n//   ...ix.message,\n//   proposer: ix.accounts[ix.proposer],\n//   payer: ix.accounts[ix.payer].addr,\n//   authorizers: ix.authorizers.map(cid => ix.accounts[cid].addr)\n// })\n//\n// encodeOutsideMessage({\n//   cadence: ___,\n//   refBlock: ___,\n//   computeLimit: ___,\n//   proposer: {\n//     addr: ___,\n//     keyId: ___,\n//     sequenceNum: __,\n//   },\n//   payer: ___,\n//   authorizers: [___],\n//   payloadSigs: [{ addr, keyId, signature }],\n// })\n//\n// encodeOutsideMessage({\n//   ...ix.message,\n//   proposer: ix.accounts[ix.proposer],\n//   payer: ix.accounts[ix.payer].addr,\n//   authorizers: ix.authorizers.map(cid => ix.accounts[cid].addr),\n//   payloadSigs: insideSignatures,\n// })\n"]},"metadata":{},"sourceType":"module"}