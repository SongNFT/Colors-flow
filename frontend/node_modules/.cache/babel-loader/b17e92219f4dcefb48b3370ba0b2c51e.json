{"ast":null,"code":"import { decodeResponse as r } from \"@onflow/decode\";\nimport { config as e } from \"@onflow/config\";\n\nvar o = function (o) {\n  try {\n    return Promise.resolve(e().where(/^decoder\\./)).then(function (e) {\n      var t = Object.entries(e).map(function (r) {\n        var e = r[0],\n            o = r[1];\n        return [e = \"/\" + e.replace(/^decoder\\./, \"\") + \"$/\", o];\n      });\n      return r(o, Object.fromEntries(t));\n    });\n  } catch (r) {\n    return Promise.reject(r);\n  }\n};\n\nexport { o as decode };","map":{"version":3,"sources":["../src/index.js"],"names":["decode","response","decodersFromConfig","config","where","decoders","Object","entries","map","pattern","xform","replace","decodeResponse","fromEntries"],"mappings":";;;AAGsBA,IAAAA,CAAAA,GAAAA,UAAOC,CAAPD,EAAOC;AAAAA,MAAAA;AAAAA,WAAAA,OAAAA,CAAAA,OAAAA,CACME,CAAAA,GAASC,KAATD,CAAe,YAAfA,CADNF,EACqB,IADrBA,CACqB,UAA1CC,CAA0C,EAA1CA;AACN,UAAMG,CAAAA,GAAWC,MAAAA,CAAOC,OAAPD,CAAeJ,CAAfI,EAAmCE,GAAnCF,CACf,UAAA,CAAA,EAAA;AAAA,YAAEG,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAF;AAAA,YAAWC,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAX;AAEE,eAAO,CADPD,CAAAA,GAAAA,MAAcA,CAAAA,CAAQE,OAARF,CAAgB,YAAhBA,EAA8B,EAA9BA,CAAdA,GAA4C,IACrC,EAAUC,CAAV,CAAP;AAAiBA,OAHJJ,CAAjB;AAOA,aAAOM,CAAAA,CAAeX,CAAfW,EAAyBN,MAAAA,CAAOO,WAAPP,CAAmBD,CAAnBC,CAAzBM,CAAP;AAAmDP,KATxBJ,CAAAA;AAA7B,GAA6BA,CAA7B,OAAA,CAAA,EAAA;AAAA,WAAA,OAAA,CAAA,MAAA,CAAA,CAAA,CAAA;AAAA;AAAA,CAAsBD;;AAAtB,SAAA,CAAA,IAAA,MAAA","sourcesContent":["import {decodeResponse} from \"@onflow/decode\"\nimport {config} from \"@onflow/config\"\n\nexport async function decode(response) {\n  const decodersFromConfig = await config().where(/^decoder\\./)\n  const decoders = Object.entries(decodersFromConfig).map(\n    ([pattern, xform]) => {\n      pattern = `/${pattern.replace(/^decoder\\./, \"\")}$/`\n      return [pattern, xform]\n    }\n  )\n\n  return decodeResponse(response, Object.fromEntries(decoders))\n}\n"]},"metadata":{},"sourceType":"module"}