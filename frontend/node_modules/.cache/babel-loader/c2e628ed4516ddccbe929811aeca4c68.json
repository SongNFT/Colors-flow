{"ast":null,"code":"import { encode as n } from \"@onflow/rlp\";\n\nvar e = function (n) {\n  return c(a(n));\n},\n    r = function (n) {\n  return c(i(n));\n},\n    t = function (n, e) {\n  return Buffer.from(n.padStart(2 * e, 0), \"hex\");\n},\n    o = function (n) {\n  return t(n, 8);\n},\n    u = function (n) {\n  return Buffer.from(JSON.stringify(n), \"utf8\");\n},\n    c = function (e) {\n  return n(e).toString(\"hex\");\n},\n    a = function (n) {\n  return d(n), [(r = n.script, Buffer.from(r, \"utf8\")), n.arguments.map(u), (e = n.refBlock, t(e, 32)), n.gasLimit, o(n.proposalKey.address), n.proposalKey.keyId, n.proposalKey.sequenceNum, o(n.payer), n.authorizers.map(o)];\n  var e, r;\n},\n    i = function (n) {\n  return p(n), [a(n), f(n)];\n},\n    f = function (n) {\n  var e = s(n);\n  return n.payloadSigs.map(function (n) {\n    return {\n      signerIndex: e.get(n.address),\n      keyId: n.keyId,\n      sig: n.sig\n    };\n  }).sort(function (n, e) {\n    return n.signerIndex > e.signerIndex ? 1 : n.signerIndex < e.signerIndex ? -1 : n.keyId > e.keyId ? 1 : n.keyId < e.keyId ? -1 : void 0;\n  }).map(function (n) {\n    return [n.signerIndex, n.keyId, (e = n.sig, Buffer.from(e, \"hex\"))];\n    var e;\n  });\n},\n    s = function (n) {\n  var e = new Map(),\n      r = 0,\n      t = function (n) {\n    e.has(n) || (e.set(n, r), r++);\n  };\n\n  return t(n.proposalKey.address), t(n.payer), n.authorizers.forEach(t), e;\n},\n    d = function (n) {\n  k.forEach(function (e) {\n    return v(n, e);\n  }), g.forEach(function (e) {\n    return v(n.proposalKey, e, \"proposalKey\");\n  });\n},\n    p = function (n) {\n  I.forEach(function (e) {\n    return v(n, e);\n  }), n.payloadSigs.forEach(function (n, e) {\n    x.forEach(function (r) {\n      return v(n, r, \"payloadSigs\", e);\n    });\n  });\n},\n    l = function (n) {\n  return \"number\" == typeof n;\n},\n    m = function (n) {\n  return \"string\" == typeof n;\n},\n    h = function (n) {\n  return null !== n && \"object\" == typeof n;\n},\n    y = function (n) {\n  return h(n) && n instanceof Array;\n},\n    k = [{\n  name: \"script\",\n  check: m\n}, {\n  name: \"arguments\",\n  check: y\n}, {\n  name: \"refBlock\",\n  check: m,\n  defaultVal: \"0\"\n}, {\n  name: \"gasLimit\",\n  check: l\n}, {\n  name: \"proposalKey\",\n  check: h\n}, {\n  name: \"payer\",\n  check: m\n}, {\n  name: \"authorizers\",\n  check: y\n}],\n    g = [{\n  name: \"address\",\n  check: m\n}, {\n  name: \"keyId\",\n  check: l\n}, {\n  name: \"sequenceNum\",\n  check: l\n}],\n    I = [{\n  name: \"payloadSigs\",\n  check: y\n}],\n    x = [{\n  name: \"address\",\n  check: m\n}, {\n  name: \"keyId\",\n  check: l\n}, {\n  name: \"sig\",\n  check: m\n}],\n    v = function (n, e, r, t) {\n  var o = e.name,\n      u = e.check,\n      c = e.defaultVal;\n  if (null == n[o] && null != c && (n[o] = c), null == n[o]) throw K(o, r, t);\n  if (!u(n[o])) throw S(o, r, t);\n},\n    E = function (n, e, r) {\n  return e ? null == r ? e + \".\" + n : e + \".\" + r + \".\" + n : n;\n},\n    K = function (n, e, r) {\n  return new Error(\"Missing field \" + E(n, e, r));\n},\n    S = function (n, e, r) {\n  return new Error(\"Invalid field \" + E(n, e, r));\n};\n\nexport { r as encodeTransactionEnvelope, e as encodeTransactionPayload };","map":{"version":3,"sources":["../src/encode.js"],"names":["encodeTransactionPayload","rlpEncode","preparePayload","tx","encodeTransactionEnvelope","prepareEnvelope","paddedHexBuffer","value","pad","Buffer","from","padStart","addressBuffer","addr","block","argumentToString","JSON","stringify","arg","script","signature","encode","v","toString","validatePayload","arguments","map","refBlock","gasLimit","proposalKey","address","keyId","sequenceNum","payer","authorizers","validateEnvelope","preparePayloadSignatures","signers","collectSigners","payloadSigs","signerIndex","get","sig","sort","a","b","Map","i","addSigner","has","set","forEach","payloadFields","checkField","field","proposalKeyFields","envelopeFields","index","payloadSigFields","isNumber","isString","isObject","isArray","Array","name","check","defaultVal","obj","base","missingFieldError","invalidFieldError","printFieldName","Error"],"mappings":"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","sourcesContent":["import { encode } from '@onflow/rlp';\n\nexport const encodeTransactionPayload = tx => rlpEncode(preparePayload(tx))\nexport const encodeTransactionEnvelope = tx => rlpEncode(prepareEnvelope(tx))\n\nconst paddedHexBuffer = (value, pad) =>\n  Buffer.from(value.padStart(pad * 2, 0), \"hex\")\n\nconst addressBuffer = addr => paddedHexBuffer(addr, 8)\n\nconst blockBuffer = block => paddedHexBuffer(block, 32)\n\nconst argumentToString = arg => Buffer.from(JSON.stringify(arg), \"utf8\")\n\nconst scriptBuffer = script => Buffer.from(script, \"utf8\")\nconst signatureBuffer = signature => Buffer.from(signature, \"hex\")\n\nconst rlpEncode = v => {\n  return encode(v).toString(\"hex\")\n}\n\nconst preparePayload = tx => {\n  validatePayload(tx)\n\n  return [\n    scriptBuffer(tx.script),\n    tx.arguments.map(argumentToString),\n    blockBuffer(tx.refBlock),\n    tx.gasLimit,\n    addressBuffer(tx.proposalKey.address),\n    tx.proposalKey.keyId,\n    tx.proposalKey.sequenceNum,\n    addressBuffer(tx.payer),\n    tx.authorizers.map(addressBuffer),\n  ]\n}\n\nconst prepareEnvelope = tx => {\n  validateEnvelope(tx)\n\n  return [preparePayload(tx), preparePayloadSignatures(tx)]\n}\n\nconst preparePayloadSignatures = tx => {\n  const signers = collectSigners(tx)\n\n  return tx.payloadSigs\n    .map(sig => {\n      return {\n        signerIndex: signers.get(sig.address),\n        keyId: sig.keyId,\n        sig: sig.sig,\n      }\n    })\n    .sort((a, b) => {\n      if (a.signerIndex > b.signerIndex) return 1\n      if (a.signerIndex < b.signerIndex) return -1\n\n      if (a.keyId > b.keyId) return 1\n      if (a.keyId < b.keyId) return -1\n    })\n    .map(sig => {\n      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)]\n    })\n}\n\nconst collectSigners = tx => {\n  const signers = new Map()\n  let i = 0\n\n  const addSigner = addr => {\n    if (!signers.has(addr)) {\n      signers.set(addr, i)\n      i++\n    }\n  }\n\n  addSigner(tx.proposalKey.address)\n  addSigner(tx.payer)\n  tx.authorizers.forEach(addSigner)\n\n  return signers\n}\n\nconst validatePayload = tx => {\n  payloadFields.forEach(field => checkField(tx, field))\n  proposalKeyFields.forEach(field =>\n    checkField(tx.proposalKey, field, \"proposalKey\")\n  )\n}\n\nconst validateEnvelope = tx => {\n  envelopeFields.forEach(field => checkField(tx, field))\n  tx.payloadSigs.forEach((sig, index) => {\n    payloadSigFields.forEach(field =>\n      checkField(sig, field, \"payloadSigs\", index)\n    )\n  })\n}\n\nconst isNumber = v => typeof v === \"number\"\nconst isString = v => typeof v === \"string\"\nconst isObject = v => v !== null && typeof v === \"object\"\nconst isArray = v => isObject(v) && v instanceof Array\n\nconst payloadFields = [\n  {name: \"script\", check: isString},\n  {name: \"arguments\", check: isArray},\n  {name: \"refBlock\", check: isString, defaultVal: \"0\"},\n  {name: \"gasLimit\", check: isNumber},\n  {name: \"proposalKey\", check: isObject},\n  {name: \"payer\", check: isString},\n  {name: \"authorizers\", check: isArray},\n]\n\nconst proposalKeyFields = [\n  {name: \"address\", check: isString},\n  {name: \"keyId\", check: isNumber},\n  {name: \"sequenceNum\", check: isNumber},\n]\n\nconst envelopeFields = [{name: \"payloadSigs\", check: isArray}]\n\nconst payloadSigFields = [\n  {name: \"address\", check: isString},\n  {name: \"keyId\", check: isNumber},\n  {name: \"sig\", check: isString},\n]\n\nconst checkField = (obj, field, base, index) => {\n  const {name, check, defaultVal} = field\n  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal\n  if (obj[name] == null) throw missingFieldError(name, base, index)\n  if (!check(obj[name])) throw invalidFieldError(name, base, index)\n}\n\nconst printFieldName = (field, base, index) => {\n  if (!!base)\n    return index == null ? `${base}.${field}` : `${base}.${index}.${field}`\n  return field\n}\n\nconst missingFieldError = (field, base, index) =>\n  new Error(`Missing field ${printFieldName(field, base, index)}`)\nconst invalidFieldError = (field, base, index) =>\n  new Error(`Invalid field ${printFieldName(field, base, index)}`)\n"]},"metadata":{},"sourceType":"module"}