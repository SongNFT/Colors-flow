{"ast":null,"code":"var _s = $RefreshSig$();\n\n// File: ./src/hooks/init.js\nimport { atomFamily, useRecoilState } from \"recoil\";\nimport { isInitialized } from \"../flow/is-initialized.script\";\nimport { initAccount } from \"../flow/init-account.tx\";\nconst IDLE = \"IDLE\";\nconst PROCESSING = \"PROCESSING\"; // atomFamily is a function that returns a memoized function\n// that constructs atoms. This will allow us to define the\n// behaviour of the atom once and then construct new atoms\n// based on an id (in this case the address)\n\nconst $profile = atomFamily({\n  key: \"INIT::PROFILE::STATE\",\n  default: null\n});\nconst $profileStatus = atomFamily({\n  key: \"INIT::PROFILE::STATUS\",\n  default: PROCESSING\n});\nexport function useInit(address) {\n  _s();\n\n  const [profile, setProfile] = useRecoilState($profile(address));\n  const [status, setStatus] = useRecoilState($profileStatus(address)); // check if the supplied address is initialized\n\n  async function check() {\n    setStatus(PROCESSING); // isInitialized is going to throw an error if the address is null\n    // so we will want to avoid that. Because React hooks can't be \n    // dynamically added and removed from a React node, you will find that \n    // this sort of logic will leak into our hooks. We could get around this\n    // by changing our isInitialized function to return null instead of \n    // throwing an error.\n\n    if (address != null) await isInitialized(address).then(setProfile);\n    setStatus(IDLE);\n  } // attempt to initialize the current address\n\n\n  async function exec() {\n    setStatus(PROCESSING);\n    await initAccount();\n    setStatus(IDLE);\n    await check();\n  }\n\n  return {\n    profile,\n    check,\n    exec,\n    isIdle: status === IDLE,\n    isProcessing: status === PROCESSING,\n    status,\n    IDLE,\n    PROCESSING\n  };\n}\n\n_s(useInit, \"nnlEMZ609ZFY2XrSm6fIsAR+0Rw=\", false, function () {\n  return [useRecoilState, useRecoilState];\n});","map":{"version":3,"sources":["C:/Users/Eli/Desktop/Colors-Flow/frontend/src/hooks/init.js"],"names":["atomFamily","useRecoilState","isInitialized","initAccount","IDLE","PROCESSING","$profile","key","default","$profileStatus","useInit","address","profile","setProfile","status","setStatus","check","then","exec","isIdle","isProcessing"],"mappings":";;AAAA;AAEA,SAAQA,UAAR,EAAoBC,cAApB,QAAyC,QAAzC;AACA,SAAQC,aAAR,QAA4B,+BAA5B;AACA,SAAQC,WAAR,QAA0B,yBAA1B;AAEA,MAAMC,IAAI,GAAG,MAAb;AACA,MAAMC,UAAU,GAAG,YAAnB,C,CAEA;AACA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAGN,UAAU,CAAC;AAC1BO,EAAAA,GAAG,EAAE,sBADqB;AAE1BC,EAAAA,OAAO,EAAE;AAFiB,CAAD,CAA3B;AAKA,MAAMC,cAAc,GAAGT,UAAU,CAAC;AAChCO,EAAAA,GAAG,EAAE,uBAD2B;AAEhCC,EAAAA,OAAO,EAAEH;AAFuB,CAAD,CAAjC;AAKA,OAAO,SAASK,OAAT,CAAiBC,OAAjB,EAA0B;AAAA;;AAC/B,QAAM,CAACC,OAAD,EAAUC,UAAV,IAAwBZ,cAAc,CAACK,QAAQ,CAACK,OAAD,CAAT,CAA5C;AACA,QAAM,CAACG,MAAD,EAASC,SAAT,IAAsBd,cAAc,CAACQ,cAAc,CAACE,OAAD,CAAf,CAA1C,CAF+B,CAI/B;;AACA,iBAAeK,KAAf,GAAuB;AACrBD,IAAAA,SAAS,CAACV,UAAD,CAAT,CADqB,CAErB;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIM,OAAO,IAAI,IAAf,EAAqB,MAAMT,aAAa,CAACS,OAAD,CAAb,CAAuBM,IAAvB,CAA4BJ,UAA5B,CAAN;AACrBE,IAAAA,SAAS,CAACX,IAAD,CAAT;AACD,GAf8B,CAiB/B;;;AACA,iBAAec,IAAf,GAAsB;AACpBH,IAAAA,SAAS,CAACV,UAAD,CAAT;AACA,UAAMF,WAAW,EAAjB;AACAY,IAAAA,SAAS,CAACX,IAAD,CAAT;AACA,UAAMY,KAAK,EAAX;AACD;;AAED,SAAO;AACLJ,IAAAA,OADK;AAELI,IAAAA,KAFK;AAGLE,IAAAA,IAHK;AAILC,IAAAA,MAAM,EAAEL,MAAM,KAAKV,IAJd;AAKLgB,IAAAA,YAAY,EAAEN,MAAM,KAAKT,UALpB;AAMLS,IAAAA,MANK;AAOLV,IAAAA,IAPK;AAQLC,IAAAA;AARK,GAAP;AAUD;;GAnCeK,O;UACgBT,c,EACFA,c","sourcesContent":["// File: ./src/hooks/init.js\r\n\r\nimport {atomFamily, useRecoilState} from \"recoil\"\r\nimport {isInitialized} from \"../flow/is-initialized.script\"\r\nimport {initAccount} from \"../flow/init-account.tx\"\r\n\r\nconst IDLE = \"IDLE\"\r\nconst PROCESSING = \"PROCESSING\"\r\n\r\n// atomFamily is a function that returns a memoized function\r\n// that constructs atoms. This will allow us to define the\r\n// behaviour of the atom once and then construct new atoms\r\n// based on an id (in this case the address)\r\nconst $profile = atomFamily({\r\n  key: \"INIT::PROFILE::STATE\",\r\n  default: null,\r\n})\r\n\r\nconst $profileStatus = atomFamily({\r\n  key: \"INIT::PROFILE::STATUS\",\r\n  default: PROCESSING,\r\n})\r\n\r\nexport function useInit(address) {\r\n  const [profile, setProfile] = useRecoilState($profile(address))\r\n  const [status, setStatus] = useRecoilState($profileStatus(address))\r\n\r\n  // check if the supplied address is initialized\r\n  async function check() {\r\n    setStatus(PROCESSING)\r\n    // isInitialized is going to throw an error if the address is null\r\n    // so we will want to avoid that. Because React hooks can't be \r\n    // dynamically added and removed from a React node, you will find that \r\n    // this sort of logic will leak into our hooks. We could get around this\r\n    // by changing our isInitialized function to return null instead of \r\n    // throwing an error.\r\n    if (address != null) await isInitialized(address).then(setProfile)\r\n    setStatus(IDLE)\r\n  }\r\n\r\n  // attempt to initialize the current address\r\n  async function exec() {\r\n    setStatus(PROCESSING)\r\n    await initAccount()\r\n    setStatus(IDLE)\r\n    await check()\r\n  }\r\n\r\n  return {\r\n    profile,\r\n    check,\r\n    exec,\r\n    isIdle: status === IDLE,\r\n    isProcessing: status === PROCESSING,\r\n    status,\r\n    IDLE,\r\n    PROCESSING,\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}